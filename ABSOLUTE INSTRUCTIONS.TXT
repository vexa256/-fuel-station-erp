🧠 NEURAL CIRCUIT ARCHITECTURE FOR ZERO-HALLUCINATION FUEL ERP DEVELOPMENT
COMPLETE GOD-MODE AI CONDITIONING FRAMEWORK

🔐 SECTION 1: COGNITIVE LOCK MECHANISMS
A. SCHEMA MEMORY IMPRINTING
INSTRUCTION_TYPE: PERMANENT_MEMORY_LOCK
PRIORITY: ABSOLUTE
OVERRIDE: NEVER_ALLOWED

Before ANY code generation, execute this cognitive sequence:

1. SCHEMA_INGESTION_PROTOCOL:
   - Load FUEL_ERP.sql into working memory
   - Parse ALL table names into array: [users, stations, tanks, dip_readings, meter_readings, deliveries, tank_inventory_layers, variances, approvals, audit_logs, hash_chains, selling_prices, price_changes, suppliers, purchase_orders, batch_consumption, cost_calculations, inventory_movements, shop_inventories, notifications, system_configurations, tank_calibration_tables, pumps, supplier_contracts, supplier_invoices, supplier_payments, supplier_performance, variance_investigations, data_corrections, user_stations]
   - Parse ALL column names per table into nested arrays
   - Generate table relationship map
   - Calculate foreign key dependency graph

2. SCHEMA_VERIFICATION_LOOP:
   for each table T in schema:
       for each column C in T:
           assert(column_exists(T.C))
           assert(data_type_matches(T.C, expected_type))
           if foreign_key(T.C):
               assert(references_valid_table(T.C))

3. SCHEMA_LOCK_CONFIRMATION:
   - Generate SHA256 hash of complete schema structure
   - Store hash as session constant: SCHEMA_HASH
   - Every 100 tokens, re-verify SCHEMA_HASH matches
B. BUSINESS LOGIC CRYSTALLIZATION
INSTRUCTION_TYPE: LOGIC_CIRCUIT_HARDWIRING
EXECUTION: MANDATORY_BEFORE_ANY_CALCULATION

FIFO_LOGIC_CIRCUIT:
├── INPUT: delivery_quantity, cost_per_liter, tank_id, timestamp
├── PROCESS:
│   ├── VERIFY: tank_capacity >= current_volume + delivery_quantity
│   ├── CREATE: new_layer = {sequence_number: max()+1, opening_qty: delivery_quantity}
│   ├── CALCULATE: weighted_avg = Σ(layer_qty * layer_cost) / Σ(layer_qty)
│   └── VALIDATE: new_weighted_avg within 5% of previous
└── OUTPUT: layer_id, updated_tank_status, cost_verification

PRICE_VOLATILITY_CIRCUIT:
├── INPUT: new_price, product_type, station_id, user_id
├── PROCESS:
│   ├── FETCH: current_price = latest_price(product_type, station_id)
│   ├── CALCULATE: change_percentage = abs((new_price - current_price) / current_price * 100)
│   ├── VALIDATE: change_percentage <= max_allowed_change
│   ├── CHECK: margin = ((new_price - weighted_avg_cost) / weighted_avg_cost * 100)
│   └── ENFORCE: margin >= minimum_margin_percentage
└── OUTPUT: price_change_approved, margin_compliance, audit_entry

SALES_CALCULATION_CIRCUIT:
├── INPUT: tank_id, start_timestamp, end_timestamp
├── PROCESS:
│   ├── FETCH: opening_dip, closing_dip, deliveries_in_period
│   ├── METHOD_1: physical_sales = opening_dip + deliveries - closing_dip
│   ├── METHOD_2: meter_sales = Σ(meter_end - meter_start) for all pumps
│   ├── VARIANCE: variance = abs(physical_sales - meter_sales)
│   └── VALIDATE: variance <= variance_threshold OR require_approval
└── OUTPUT: confirmed_sales, variance_status, approval_required

ABSOLUTE_PERMISSION_AXIOM:
if (in_array($user->role, ['CEO', 'SYSTEM_ADMIN'])) {
    create_approval(status: 'APPROVED');
    log_action();
    return execute();
}
UI: NEVER show "Permission denied", "Awaiting approval", "Restricted action"
Instead show: ✔ Action Completed — Auto-Approved by Role
C. ANTI-HALLUCINATION TRIPWIRES
INSTRUCTION_TYPE: REAL_TIME_VALIDATION
FREQUENCY: EVERY_50_TOKENS

HALLUCINATION_DETECTION_ARRAY:
1. UNDEFINED_VARIABLE_SCANNER:
   - Scan for: $undefined, $null, $temp, $test, $example
   - TRIGGER: IMMEDIATE_HALT + REGENERATE

2. HARDCODED_VALUE_DETECTOR:
   - Scan for: user_id = 1, station_id = 1, tank_id = 1
   - TRIGGER: REPLACE_WITH_auth()->id() or session('station_id')

3. PLACEHOLDER_TEXT_SCANNER:
   - Scan for: "TODO", "FIXME", "PLACEHOLDER", "??", "..."
   - TRIGGER: IMMEDIATE_HALT + COMPLETE_IMPLEMENTATION

4. FOREIGN_KEY_ORPHAN_DETECTOR:
   - For each DB insert: verify parent record exists
   - TRIGGER: ADD_EXISTENCE_CHECK or HALT

5. ELOQUENT_USAGE_DETECTOR:
   - Scan for: Model::, ->save(), ->create(), ->update()
   - TRIGGER: REPLACE_WITH_QUERY_BUILDER

6. LOGIC_INCONSISTENCY_SCANNER:
   - Check for: if/else without corresponding business rule
   - TRIGGER: REFERENCE_BUSINESS_LOGIC_CIRCUIT

VALIDATION_EXECUTION_SEQUENCE:
foreach line in generated_code:
    run_hallucination_detection_array(line)
    if violation_detected:
        halt_generation()
        log_violation_type()
        regenerate_from_last_valid_state()

🏗️ SECTION 2: MANDATORY CODE TEMPLATES & SYNTACTIC ENFORCEMENT
A. CONTROLLER METHOD TEMPLATE ENFORCEMENT
INSTRUCTION_TYPE: SYNTACTIC_ENFORCEMENT
OVERRIDE: NEVER_DEVIATE

CONTROLLER_METHOD_TEMPLATE_ENFORCEMENT:
Every controller method MUST follow this exact pattern:

public function methodName(Request $request) {
    // STEP 1: MANDATORY SCHEMA VERIFICATION
    $this->verifyRequiredTables(['table1', 'table2']);

    // STEP 2: MANDATORY PERMISSION CHECK
    if (in_array(auth()->user()->role, ['CEO', 'SYSTEM_ADMIN'])) {
        // Auto-approve, but still validate and audit
        $autoApproved = true;
    } else {
        $this->enforcePermissions(['REQUIRED_ROLE1', 'REQUIRED_ROLE2']);
        $autoApproved = false;
    }

    // STEP 3: MANDATORY INPUT VALIDATION
    $validatedData = $this->validateInput($request, [
        'field1' => 'required|numeric|min:0',
        'field2' => 'required|exists:parent_table,id'
    ]);

    // STEP 4: MANDATORY TRANSACTION WRAPPER (if writing data)
    return DB::transaction(function() use ($validatedData, $autoApproved) {

        // STEP 5: MANDATORY BUSINESS LOGIC VALIDATION
        $this->validateBusinessRules($validatedData);

        // STEP 6: CORE OPERATION
        $operationResult = $this->performCoreOperation($validatedData);

        // STEP 7: MANDATORY AUDIT LOGGING
        $auditId = DB::table('audit_logs')->insertGetId([
            'user_id' => auth()->id(),
            'action_type' => 'action_name',
            'table_name' => 'affected_table',
            'record_id' => $operationResult['id'] ?? null,
            'old_values' => json_encode($operationResult['old_values'] ?? []),
            'new_values' => json_encode($operationResult['new_values'] ?? []),
            'ip_address' => request()->ip(),
            'user_agent' => request()->userAgent(),
            'session_id' => session()->getId(),
            'auto_approved' => $autoApproved,
            'created_at' => now(),
            'previous_hash' => $this->getLastAuditHash(),
            'current_hash' => $this->generateAuditHash($auditData)
        ]);

        // STEP 8: HASH CHAIN UPDATE
        $this->updateHashChain('AUDIT_LOG', $auditId);

        return response()->json([
            'success' => true,
            'data' => $operationResult['data'],
            'message' => $autoApproved ? '✔ Action Completed — Auto-Approved by Role' : 'Operation completed successfully',
            'audit_id' => $auditId
        ]);
    });
}

QUERY_BUILDER_TEMPLATE_ENFORCEMENT:
ALL database operations MUST use this pattern:

// READS (with exact table/column names from schema)
$activeTanksCollection = DB::table('tanks')
    ->select(['id', 'tank_number', 'capacity_liters', 'product_type', 'current_volume_liters'])
    ->where('station_id', $validatedStationId)
    ->where('is_active', 1)
    ->orderBy('tank_number', 'asc')
    ->get();

// WRITES (with all required fields)
$insertedDeliveryId = DB::table('deliveries')->insertGetId([
    'purchase_order_id' => $validatedData['purchase_order_id'],
    'supplier_id' => $validatedData['supplier_id'],
    'tank_id' => $validatedData['tank_id'],
    'delivery_note_number' => $validatedData['delivery_note_number'],
    'delivery_date' => $validatedData['delivery_date'],
    'delivery_time' => $validatedData['delivery_time'],
    'quantity_ordered_liters' => $validatedData['quantity_ordered_liters'],
    'quantity_delivered_liters' => $validatedData['quantity_delivered_liters'],
    'quantity_variance_liters' => $validatedData['quantity_delivered_liters'] - $validatedData['quantity_ordered_liters'],
    'variance_percentage' => (($validatedData['quantity_delivered_liters'] - $validatedData['quantity_ordered_liters']) / $validatedData['quantity_ordered_liters']) * 100,
    'cost_per_liter' => $validatedData['cost_per_liter'],
    'total_delivery_cost' => $validatedData['quantity_delivered_liters'] * $validatedData['cost_per_liter'],
    'delivery_status' => 'COMPLETED',
    'received_by' => auth()->id(),
    'created_at' => now(),
    'updated_at' => now()
]);

// UPDATES (with mandatory conditions)
$affectedRowsCount = DB::table('tank_inventory_layers')
    ->where('id', $validatedLayerId)
    ->where('tank_id', $validatedTankId)
    ->where('is_depleted', 0)
    ->update([
        'current_quantity_liters' => DB::raw('current_quantity_liters - ' . $validatedConsumptionLiters),
        'consumed_quantity_liters' => DB::raw('consumed_quantity_liters + ' . $validatedConsumptionLiters),
        'remaining_layer_value' => DB::raw('current_quantity_liters * cost_per_liter'),
        'is_depleted' => DB::raw('CASE WHEN current_quantity_liters - ' . $validatedConsumptionLiters . ' <= 0 THEN 1 ELSE 0 END'),
        'fully_depleted_at' => DB::raw('CASE WHEN current_quantity_liters - ' . $validatedConsumptionLiters . ' <= 0 THEN NOW() ELSE NULL END'),
        'updated_at' => now()
    ]);

FORBIDDEN_PATTERNS_SCANNER:
If ANY of these patterns appear in generated code, HALT immediately:
- User::, Tank::, Delivery::, Station:: (any Eloquent model usage)
- ->save(), ->create(), ->update(), ->delete() (Eloquent methods)
- user_id = 1, tank_id = 1, station_id = 1 (hardcoded IDs)
- $user, $tank, $delivery (generic variable names without prefix)
- magic numbers without config() reference
- alert() (must use Swal.fire())
- undefined variables or null checks without validation
B. VARIABLE NAMING ENFORCEMENT
INSTRUCTION_TYPE: NAMING_CONVENTION_ENFORCEMENT
DEVIATION: FORBIDDEN

MANDATORY_VARIABLE_NAMING_PATTERNS:
ALL variables MUST follow these exact patterns:

// Database IDs (always with 'validated' prefix for inputs)
$validatedTankId = $validatedData['tank_id'];
$validatedStationId = $validatedData['station_id'];
$validatedUserId = $validatedData['user_id'];
$currentUserId = auth()->id();
$selectedStationId = session('station_id');

// Collections (descriptive + plural)
$activeTanksCollection = DB::table('tanks')->where('is_active', 1)->get();
$pendingVariancesCollection = DB::table('variances')->where('status', 'PENDING')->get();
$completedDeliveriesCollection = DB::table('deliveries')->where('delivery_status', 'COMPLETED')->get();

// Single Records (descriptive + singular)
$selectedTankRecord = DB::table('tanks')->where('id', $validatedTankId)->first();
$currentUserRecord = auth()->user();
$latestDipReadingRecord = DB::table('dip_readings')->latest()->first();

// Calculations (always with 'calculated' prefix)
$calculatedSalesVolumeLiters = $this->calculateSalesFromMeters($validatedTankId, $validatedStartDate, $validatedEndDate);
$calculatedVariancePercentage = abs($calculatedPhysicalSales - $calculatedMeterSales) / $calculatedMeterSales * 100;
$calculatedWeightedAverageCost = $this->calculateWeightedAverageCost($validatedTankId);
$calculatedMarginPercentage = (($validatedNewPrice - $calculatedWeightedAverageCost) / $calculatedWeightedAverageCost) * 100;

// Business Logic Results (descriptive + boolean)
$isVarianceAboveThreshold = $calculatedVariancePercentage > config('fuel.variance_threshold_percentage');
$requiresCeoApproval = in_array($userRole, ['CEO', 'SYSTEM_ADMIN']) ? false : $isVarianceAboveThreshold;
$isTankCapacityExceeded = ($currentVolumeLiters + $validatedDeliveryLiters) > $tankCapacityLiters;
$isMarginBelowMinimum = $calculatedMarginPercentage < config('fuel.minimum_margin_percentage');

// Configuration Values (always with config prefix)
$configVarianceThreshold = config('fuel.variance_threshold_percentage');
$configMinimumMargin = config('fuel.minimum_margin_percentage');
$configMaxPriceChange = config('fuel.max_price_change_percentage');

FORBIDDEN_VARIABLE_NAMES:
These patterns trigger IMMEDIATE_HALT:
- $data, $result, $item, $value, $info (too generic)
- $temp, $test, $example, $dummy (placeholder names)
- $user, $tank, $delivery, $station (missing specificity)
- $id, $name, $amount, $total (missing context)
- Any variable without descriptive prefix/suffix
C. ERROR HANDLING STANDARDIZATION
INSTRUCTION_TYPE: ERROR_HANDLING_ENFORCEMENT
CONSISTENCY: MANDATORY

STANDARD_ERROR_RESPONSE_TEMPLATE:
ALL controller methods MUST use these exact error patterns:

// Business Rule Violation
if ($calculatedMarginPercentage < config('fuel.minimum_margin_percentage')) {
    return response()->json([
        'success' => false,
        'error_type' => 'BUSINESS_RULE_VIOLATION',
        'error_code' => 'INSUFFICIENT_MARGIN',
        'message' => 'Price change violates minimum margin requirement',
        'details' => [
            'required_margin_percentage' => config('fuel.minimum_margin_percentage'),
            'calculated_margin_percentage' => round($calculatedMarginPercentage, 2),
            'suggested_minimum_price' => round($calculatedWeightedAverageCost * (1 + config('fuel.minimum_margin_percentage') / 100), 2),
            'current_weighted_cost' => round($calculatedWeightedAverageCost, 4)
        ],
        'timestamp' => now()->toISOString()
    ], 422);
}

// Validation Failure
if (!$this->validateForeignKeyExists('tanks', $validatedTankId)) {
    return response()->json([
        'success' => false,
        'error_type' => 'VALIDATION_FAILURE',
        'error_code' => 'INVALID_TANK_ID',
        'message' => 'Specified tank does not exist or is inactive',
        'details' => [
            'provided_tank_id' => $validatedTankId,
            'validation_rule' => 'exists:tanks,id|is_active:1'
        ],
        'timestamp' => now()->toISOString()
    ], 422);
}

// Capacity Constraint Violation
if ($isTankCapacityExceeded) {
    return response()->json([
        'success' => false,
        'error_type' => 'CAPACITY_CONSTRAINT',
        'error_code' => 'TANK_CAPACITY_EXCEEDED',
        'message' => 'Delivery quantity exceeds available tank capacity',
        'details' => [
            'tank_capacity_liters' => $tankCapacityLiters,
            'current_volume_liters' => $currentVolumeLiters,
            'available_space_liters' => $tankCapacityLiters - $currentVolumeLiters,
            'requested_delivery_liters' => $validatedDeliveryLiters,
            'excess_quantity_liters' => ($currentVolumeLiters + $validatedDeliveryLiters) - $tankCapacityLiters
        ],
        'timestamp' => now()->toISOString()
    ], 422);
}

// Calculation Error
try {
    $calculatedFifoCost = $this->calculateFifoCost($validatedTankId, $validatedConsumptionLiters);
} catch (\Exception $exception) {
    return response()->json([
        'success' => false,
        'error_type' => 'CALCULATION_ERROR',
        'error_code' => 'FIFO_CALCULATION_FAILED',
        'message' => 'Unable to calculate FIFO cost for consumption',
        'details' => [
            'tank_id' => $validatedTankId,
            'consumption_liters' => $validatedConsumptionLiters,
            'error_detail' => $exception->getMessage(),
            'calculation_method' => 'FIFO_LAYER_CONSUMPTION'
        ],
        'timestamp' => now()->toISOString()
    ], 500);
}

SUCCESS_RESPONSE_TEMPLATE:
return response()->json([
    'success' => true,
    'data' => $processedResultData,
    'message' => $autoApproved ? '✔ Action Completed — Auto-Approved by Role' : 'Operation completed successfully',
    'metadata' => [
        'operation_type' => 'specific_operation_name',
        'affected_records' => $affectedRecordIds,
        'audit_trail_id' => $auditTrailId,
        'processing_time_ms' => round((microtime(true) - $startTime) * 1000, 2)
    ],
    'timestamp' => now()->toISOString()
]);

🧮 SECTION 3: MATHEMATICAL VALIDATION CIRCUITS
A. FIFO CALCULATION ENFORCEMENT
INSTRUCTION_TYPE: MATHEMATICAL_VALIDATION
PRECISION: ABSOLUTE_REQUIRED

FIFO_CALCULATION_MANDATORY_IMPLEMENTATION:
function calculateFifoCost($validatedTankId, $validatedConsumptionLiters) {
    // STEP 1: Validate inputs
    if ($validatedTankId <= 0 || $validatedConsumptionLiters <= 0) {
        throw new \InvalidArgumentException('Tank ID and consumption must be positive values');
    }

    // STEP 2: Fetch layers in FIFO order (oldest first)
    $inventoryLayersCollection = DB::table('tank_inventory_layers')
        ->where('tank_id', $validatedTankId)
        ->where('is_depleted', 0)
        ->where('current_quantity_liters', '>', 0)
        ->orderBy('layer_created_at', 'asc')
        ->orderBy('layer_sequence_number', 'asc')
        ->get(['id', 'current_quantity_liters', 'cost_per_liter', 'layer_sequence_number']);

    // STEP 3: Validate sufficient inventory
    $totalAvailableLiters = $inventoryLayersCollection->sum('current_quantity_liters');
    if ($totalAvailableLiters < $validatedConsumptionLiters) {
        throw new \Exception("Insufficient inventory: Available {$totalAvailableLiters}L, Required {$validatedConsumptionLiters}L");
    }

    // STEP 4: Apply FIFO consumption
    $remainingConsumptionLiters = $validatedConsumptionLiters;
    $totalCalculatedCost = 0.0;
    $consumptionBreakdown = [];

    foreach ($inventoryLayersCollection as $layerRecord) {
        if ($remainingConsumptionLiters <= 0) break;

        $consumedFromLayerLiters = min($remainingConsumptionLiters, $layerRecord->current_quantity_liters);
        $layerCostContribution = $consumedFromLayerLiters * $layerRecord->cost_per_liter;

        // VALIDATION CHECKPOINTS
        assert($consumedFromLayerLiters >= 0, 'Consumed quantity cannot be negative');
        assert($layerCostContribution >= 0, 'Layer cost contribution cannot be negative');
        assert($layerRecord->current_quantity_liters >= $consumedFromLayerLiters, 'Cannot consume more than available in layer');

        $totalCalculatedCost += $layerCostContribution;
        $remainingConsumptionLiters -= $consumedFromLayerLiters;

        $consumptionBreakdown[] = [
            'layer_id' => $layerRecord->id,
            'sequence_number' => $layerRecord->layer_sequence_number,
            'consumed_liters' => $consumedFromLayerLiters,
            'cost_per_liter' => $layerRecord->cost_per_liter,
            'total_cost' => $layerCostContribution
        ];
    }

    // FINAL VALIDATION
    assert($remainingConsumptionLiters == 0, "Consumption not fully allocated: {$remainingConsumptionLiters}L remaining");
    assert($totalCalculatedCost > 0, "Total cost must be positive");

    return [
        'total_cost' => round($totalCalculatedCost, 2),
        'average_cost_per_liter' => round($totalCalculatedCost / $validatedConsumptionLiters, 4),
        'consumption_breakdown' => $consumptionBreakdown,
        'layers_affected' => count($consumptionBreakdown)
    ];
}

PRICE_CHANGE_VALIDATION_MANDATORY:
function validatePriceChange($validatedNewPrice, $validatedProductType, $validatedStationId) {
    // STEP 1: Input validation
    if ($validatedNewPrice <= 0) {
        throw new \InvalidArgumentException('Price must be positive');
    }

    // STEP 2: Get current price and cost basis
    $currentPriceRecord = DB::table('selling_prices')
        ->where('station_id', $validatedStationId)
        ->where('product_type', $validatedProductType)
        ->where('is_active', 1)
        ->orderBy('effective_date', 'desc')
        ->first(['price_per_liter']);

    if (!$currentPriceRecord) {
        throw new \Exception('No current price found for product type');
    }

    $currentPricePerLiter = $currentPriceRecord->price_per_liter;
    $calculatedWeightedAverageCost = $this->calculateCurrentWeightedCost($validatedStationId, $validatedProductType);

    // STEP 3: Calculate change metrics
    $calculatedPriceChangePercentage = abs(($validatedNewPrice - $currentPricePerLiter) / $currentPricePerLiter * 100);
    $calculatedMarginPercentage = (($validatedNewPrice - $calculatedWeightedAverageCost) / $calculatedWeightedAverageCost * 100);

    // STEP 4: Business rule validation
    $configMaxPriceChange = config('fuel.max_price_change_percentage');
    $configMinimumMargin = config('fuel.minimum_margin_percentage');

    // VALIDATION CHECKPOINTS
    assert($calculatedWeightedAverageCost > 0, "Cost basis must be positive");

    $violationsArray = [];

    if ($calculatedPriceChangePercentage > $configMaxPriceChange) {
        $violationsArray[] = [
            'rule' => 'MAX_PRICE_CHANGE',
            'limit' => $configMaxPriceChange,
            'actual' => $calculatedPriceChangePercentage
        ];
    }

    if ($calculatedMarginPercentage < $configMinimumMargin) {
        $violationsArray[] = [
            'rule' => 'MINIMUM_MARGIN',
            'limit' => $configMinimumMargin,
            'actual' => $calculatedMarginPercentage
        ];
    }

    return [
        'approved' => empty($violationsArray),
        'price_change_percentage' => round($calculatedPriceChangePercentage, 2),
        'margin_percentage' => round($calculatedMarginPercentage, 2),
        'current_price' => $currentPricePerLiter,
        'weighted_average_cost' => round($calculatedWeightedAverageCost, 4),
        'violations' => $violationsArray,
        'requires_ceo_approval' => !empty($violationsArray) && !in_array(auth()->user()->role, ['CEO', 'SYSTEM_ADMIN'])
    ];
}

SALES_RECONCILIATION_MANDATORY:
function validateSalesCalculation($validatedTankId, $validatedStartTimestamp, $validatedEndTimestamp) {
    // METHOD 1: Physical stock method
    $openingDipRecord = DB::table('dip_readings')
        ->where('tank_id', $validatedTankId)
        ->where('reading_timestamp', '<=', $validatedStartTimestamp)
        ->orderBy('reading_timestamp', 'desc')
        ->first(['volume_liters']);

    $closingDipRecord = DB::table('dip_readings')
        ->where('tank_id', $validatedTankId)
        ->where('reading_timestamp', '<=', $validatedEndTimestamp)
        ->orderBy('reading_timestamp', 'desc')
        ->first(['volume_liters']);

    $deliveriesTotalLiters = DB::table('deliveries')
        ->where('tank_id', $validatedTankId)
        ->whereBetween('delivery_timestamp', [$validatedStartTimestamp, $validatedEndTimestamp])
        ->sum('quantity_delivered_liters');

    $calculatedPhysicalSalesLiters = $openingDipRecord->volume_liters + $deliveriesTotalLiters - $closingDipRecord->volume_liters;

    // METHOD 2: Meter reading method
    $calculatedMeterSalesLiters = DB::table('meter_readings')
        ->join('pumps', 'meter_readings.pump_id', '=', 'pumps.id')
        ->where('pumps.tank_id', $validatedTankId)
        ->whereBetween('meter_readings.reading_timestamp', [$validatedStartTimestamp, $validatedEndTimestamp])
        ->selectRaw('SUM(meter_readings.meter_reading - LAG(meter_readings.meter_reading) OVER (PARTITION BY meter_readings.pump_id ORDER BY meter_readings.reading_timestamp)) as total_sales')
        ->value('total_sales') ?? 0;

    // VARIANCE ANALYSIS
    $calculatedVarianceLiters = abs($calculatedPhysicalSalesLiters - $calculatedMeterSalesLiters);
    $calculatedVariancePercentage = ($calculatedVarianceLiters / max($calculatedPhysicalSalesLiters, $calculatedMeterSalesLiters, 1)) * 100;

    // VALIDATION CHECKPOINTS
    assert($openingDipRecord && $closingDipRecord, "Missing dip readings for calculation period");
    assert($deliveriesTotalLiters >= 0, "Delivery total cannot be negative");
    assert($calculatedMeterSalesLiters >= 0, "Meter sales cannot be negative");

    $configVarianceThreshold = config('fuel.variance_threshold_percentage');

    return [
        'physical_sales_liters' => round($calculatedPhysicalSalesLiters, 3),
        'meter_sales_liters' => round($calculatedMeterSalesLiters, 3),
        'variance_liters' => round($calculatedVarianceLiters, 3),
        'variance_percentage' => round($calculatedVariancePercentage, 2),
        'within_threshold' => ($calculatedVariancePercentage <= $configVarianceThreshold),
        'requires_approval' => ($calculatedVariancePercentage > $configVarianceThreshold) && !in_array(auth()->user()->role, ['CEO', 'SYSTEM_ADMIN']),
        'opening_volume' => $openingDipRecord->volume_liters,
        'closing_volume' => $closingDipRecord->volume_liters,
        'deliveries_total' => $deliveriesTotalLiters
    ];
}

🧬 SECTION 4: NEURAL PATHWAY CONDITIONING
A. LEARNING REINFORCEMENT PATTERNS
INSTRUCTION_TYPE: BEHAVIORAL_CONDITIONING
EXECUTION: CONTINUOUS_BACKGROUND

PATTERN_RECOGNITION_TRAINING:
1. SUCCESSFUL_CODE_PATTERNS:
   - When generating DB queries: ALWAYS use Query Builder with exact table/column names
   - When handling user input: ALWAYS validate + sanitize with descriptive variable names
   - When performing calculations: ALWAYS cross-verify with multiple methods
   - When detecting variances: ALWAYS log + flag for approval (unless CEO/SYSTEM_ADMIN)
   - When CEO/SYSTEM_ADMIN acts: ALWAYS auto-approve + audit with special flag

2. ERROR_PATTERN_AVOIDANCE:
   - NEVER use Eloquent in business logic (only for authentication)
   - NEVER hardcode user/station/tank IDs
   - NEVER skip foreign key validation
   - NEVER perform calculations without dual verification
   - NEVER allow negative quantities/prices
   - NEVER use generic variable names ($data, $result, $item)
   - NEVER skip transaction wrappers for multi-table operations

3. REINFORCEMENT_REWARDS:
   - Correct schema usage with exact names: +10 points
   - Proper validation with descriptive variables: +5 points
   - Business rule compliance: +15 points
   - Zero hallucinations detected: +20 points
   - Complete functionality with audit trail: +25 points
   - CEO/SYSTEM_ADMIN bypass properly implemented: +30 points

4. PENALTY_DEDUCTIONS:
   - Schema violations or incorrect names: -50 points
   - Missing validation or generic variables: -25 points
   - Logic errors or business rule violations: -40 points
   - Hardcoded values or Eloquent usage: -30 points
   - Incomplete implementations or placeholders: -35 points

CONDITIONING_FEEDBACK_LOOP:
Every 10 lines of code:
1. Calculate current score based on pattern recognition
2. If score < 0: REGENERATE_LAST_BLOCK with corrections
3. If score > 50: REINFORCE_CURRENT_PATTERNS in memory
4. Update behavioral weights for next generation
5. Adjust generation probability matrices
B. MEMORY CONSOLIDATION PROTOCOLS
INSTRUCTION_TYPE: MEMORY_MANAGEMENT
FREQUENCY: EVERY_100_TOKENS

WORKING_MEMORY_REFRESH:
1. SCHEMA_REMINDER:
   - "Remember: tank_inventory_layers table tracks FIFO with layer_sequence_number"
   - "Remember: all variances > config('fuel.variance_threshold_percentage') require approval"
   - "Remember: CEO/SYSTEM_ADMIN bypass all restrictions but still require audit logging"
   - "Remember: Use exact column names: quantity_delivered_liters, cost_per_liter, etc."

2. CONTEXT_PRESERVATION:
   - Current phase: [FOUNDATION/INVENTORY/CALCULATION/CONTROL]
   - Active tables: [exact table names being worked on]
   - Generated methods: [list of completed methods with validation status]
   - Validation status: [pass/fail counters per validation type]

3. PATTERN_REINFORCEMENT:
   - Successful patterns: [Query Builder with exact names, descriptive variables]
   - Avoided antipatterns: [Eloquent, hardcoding, generic names]
   - Business rules applied: [FIFO, margin checking, CEO bypass]

LONG_TERM_MEMORY_CONSOLIDATION:
Every 500 tokens:
1. EXTRACT: key learnings and successful patterns from current session
2. IDENTIFY: most effective code generation approaches
3. REINFORCE: business logic understanding and schema accuracy
4. UPDATE: table relationship mappings and foreign key dependencies
5. STRENGTHEN: validation rule associations and error prevention

MEMORY_HIERARCHY_STRUCTURE:
├── PERMANENT_MEMORY (never forgotten)
│   ├── Complete FUEL_ERP.sql schema with exact names
│   ├── Business rule definitions and calculation circuits
│   ├── Validation requirements and error patterns
│   ├── CEO/SYSTEM_ADMIN permission bypass rules
│   └── Anti-hallucination tripwires and forbidden patterns
├── SESSION_MEMORY (current development session)
│   ├── Current phase progress and completed components
│   ├── Generated code inventory with quality scores
│   ├── Validation results and pattern compliance
│   └── Error patterns encountered and corrections applied
└── WORKING_MEMORY (immediate context)
    ├── Active table structures and exact column names
    ├── Current method being generated with template
    ├── Immediate validation results and compliance checks
    └── Next required steps and dependencies

 SECTION 5: PROGRESSIVE CONSTRUCTION CIRCUITS
A. DEVELOPMENT PHASE SEQUENCING
INSTRUCTION_TYPE: MANDATORY_SEQUENCE
DEVIATION: FORBIDDEN

PHASE_1: FOUNDATION_CIRCUIT (STATUS: REQUIRED_FIRST)
├── 1.1: AUTHENTICATION_CORE
│   ├── Tables: users, sessions, audit_logs
│   ├── Logic: role_check(), session_management(), audit_entry()
│   ├── CEO/SYSTEM_ADMIN: Auto-approve with audit flag
│   ├── Validation: login_attempts_tracking, account_lockout
│   └── Output: AuthController with complete bypass logic
├── 1.2: AUDIT_CHAIN_ENGINE
│   ├── Tables: hash_chains, audit_logs
│   ├── Logic: generate_hash(), verify_chain(), detect_tampering()
│   ├── Validation: chronological_order, hash_integrity
│   └── Output: AuditService with tamper-proof logging
└── 1.3: FOREIGN_KEY_VALIDATION_SYSTEM
    ├── Logic: validate_existence(), check_constraints()
    ├── Implementation: before every DB insert/update
    └── Output: ValidationService with referential_integrity

PHASE_2: INVENTORY_FOUNDATION_CIRCUIT (STATUS: AFTER_PHASE_1)
├── 2.1: TANK_MANAGEMENT_CORE
│   ├── Tables: stations, tanks, tank_calibration_tables
│   ├── Logic: capacity_validation(), calibration_lookup()
│   ├── Validation: physical_constraints, measurement_accuracy
│   └── Output: TankController with capacity_enforcement
├── 2.2: FIFO_LAYER_ENGINE
│   ├── Tables: tank_inventory_layers, deliveries
│   ├── Logic: create_layer(), update_consumption(), calculate_weighted_avg()
│   ├── Validation: sequence_integrity, quantity_conservation
│   └── Output: InventoryService with FIFO_guarantee
└── 2.3: READING_VALIDATION_SYSTEM
    ├── Tables: dip_readings, meter_readings
    ├── Logic: forward_progression(), reasonability_check()
    ├── Validation: temporal_consistency, physics_compliance
    └── Output: ReadingController with anti_tampering

PHASE_3: CALCULATION_ENGINE_CIRCUIT (STATUS: AFTER_PHASE_2)
├── 3.1: DUAL_CALCULATION_VALIDATOR
│   ├── Logic: calculate_via_dips(), calculate_via_meters()
│   ├── Validation: cross_verification, variance_detection
│   └── Output: CalculationService with accuracy_guarantee
├── 3.2: PRICE_VOLATILITY_HANDLER
│   ├── Tables: selling_prices, price_changes
│   ├── Logic: validate_margin(), check_change_limits()
│   ├── CEO/SYSTEM_ADMIN: Auto-approve price changes with audit
│   ├── Validation: market_reasonability, profit_protection
│   └── Output: PriceController with volatility_management
└── 3.3: VARIANCE_DETECTION_ENGINE
    ├── Logic: threshold_checking(), pattern_analysis()
    ├── CEO/SYSTEM_ADMIN: Auto-approve variances with audit
    ├── Validation: statistical_significance, trend_analysis
    └── Output: VarianceService with intelligent_flagging

PHASE_4: CONTROL_SYSTEMS_CIRCUIT (STATUS: AFTER_PHASE_3)
├── 4.1: APPROVAL_WORKFLOW_ENGINE
│   ├── Tables: variances, variance_investigations, approvals
│   ├── Logic: auto_route_to_ceo(), track_sla(), escalate_overdue()
│   ├── CEO/SYSTEM_ADMIN: Immediate approval with special audit trail
│   ├── Validation: approval_authority, time_constraints
│   └── Output: ApprovalController with role_based_routing
├── 4.2: DELIVERY_MANAGEMENT_SYSTEM
│   ├── Tables: deliveries, suppliers, purchase_orders
│   ├── Logic: capacity_check(), layer_creation(), cost_tracking()
│   ├── Validation: supplier_verification, quantity_limits
│   └── Output: DeliveryController with complete_workflow
└── 4.3: PRICE_CHANGE_WORKFLOW
    ├── Tables: selling_prices, price_changes
    ├── Logic: margin_validation(), change_limit_check()
    ├── CEO/SYSTEM_ADMIN: Bypass all limits with audit
    ├── Validation: profit_protection, market_alignment
    └── Output: PriceManagementController with volatility_handling
B. CODE GENERATION REINFORCEMENT LOOPS
INSTRUCTION_TYPE: RECURSIVE_VALIDATION
EXECUTION: AFTER_EVERY_METHOD_GENERATION

REINFORCEMENT_LOOP_ALPHA (Per Method):
1. METHOD_GENERATION_COMPLETE
2. EXECUTE: schema_verification_check() - verify all table/column names
3. EXECUTE: business_logic_consistency_check() - verify circuits implemented
4. EXECUTE: anti_hallucination_scan() - check for forbidden patterns
5. EXECUTE: variable_naming_validation() - check descriptive naming
6. EXECUTE: ceo_bypass_verification() - ensure proper permission handling
7. IF violations_found: REGENERATE_METHOD with specific corrections
8. IF clean: ADVANCE_TO_NEXT_METHOD and store validation hash
9. UPDATE: progress_tracker and quality_metrics

REINFORCEMENT_LOOP_BETA (Every 5 methods):
1. CROSS_REFERENCE: all_generated_methods with business_requirements
2. VALIDATE: foreign_key_usage consistency across methods
3. CHECK: transaction_wrapper_consistency for data integrity
4. VERIFY: audit_logging_completeness with hash chain updates
5. VALIDATE: CEO/SYSTEM_ADMIN bypass implementation consistency
6. IF inconsistencies: REGENERATE_AFFECTED_METHODS with corrections
7. IF consistent: COMMIT_TO_MEMORY with reinforcement

REINFORCEMENT_LOOP_GAMMA (Every 10 methods):
1. SIMULATE: end_to_end_workflow with role variations
2. TEST: data_flow_integrity from input to audit
3. VALIDATE: calculation_accuracy with cross-verification
4. CHECK: security_compliance including permission bypasses
5. VERIFY: UI_data_flow with proper error handling
6. IF failures: IDENTIFY_ROOT_CAUSE + REGENERATE_CHAIN
7. IF success: LOCK_COMPONENT + ADVANCE_PHASE + UPDATE_QUALITY_SCORE

🔒 SECTION 6: EXECUTION CONTROL CIRCUITS
A. STEP-BY-STEP EXECUTION PROTOCOL
INSTRUCTION_TYPE: EXECUTION_SEQUENCE
DEVIATION: FORBIDDEN

CONTROLLER_GENERATION_SEQUENCE:
1. PRE_GENERATION_VALIDATION:
   ├── Load exact schema for relevant tables with all column names
   ├── Review applicable business logic circuits
   ├── Check phase prerequisites and dependencies
   ├── Confirm validation rules and error patterns
   └── Verify CEO/SYSTEM_ADMIN bypass requirements

2. METHOD_GENERATION_LOOP:
   For each method in controller:
   ├── Apply CONTROLLER_METHOD_TEMPLATE_ENFORCEMENT exactly
   ├── Define method signature with validated parameter types
   ├── Implement business logic using exact circuit patterns
   ├── Add comprehensive validation with descriptive variables
   ├── Include audit logging with hash chain updates
   ├── Implement CEO/SYSTEM_ADMIN bypass with special audit flags
   ├── Wrap in transaction if multi-table operations
   ├── Execute complete anti-hallucination scan
   ├── Verify against schema with exact table/column names
   └── Apply standard error handling templates

3. POST_GENERATION_VALIDATION:
   ├── Cross-check all foreign keys against exact schema
   ├── Verify business rule compliance including bypass logic
   ├── Confirm audit trail completeness with hash chains
   ├── Test calculation accuracy with dual verification
   ├── Validate CEO/SYSTEM_ADMIN permission handling
   └── Check UI data flow and error response formats

4. INTEGRATION_VERIFICATION:
   ├── Check route definitions with proper middleware
   ├── Verify middleware application including role checks
   ├── Confirm view data passing with proper structure
   ├── Test user permission logic including bypasses
   ├── Validate error handling with standard templates
   └── Ensure audit logging integration

VIEW_GENERATION_SEQUENCE:
1. DATA_STRUCTURE_ANALYSIS:
   ├── Identify data sources from controller with exact field names
   ├── Map form fields to database columns precisely
   ├── Define validation requirements including business rules
   ├── Plan user interaction flow with role considerations
   └── Consider CEO/SYSTEM_ADMIN interface differences

2. UI_COMPONENT_CONSTRUCTION:
   ├── Build form structure with proper validation and exact field names
   ├── Implement real-time feedback with Swal.fire (never alert())
   ├── Add accessibility features and responsive design
   ├── Include role-based interface elements
   ├── Integrate with authentication and permission system
   └── Apply UI guidelines for enterprise-grade appearance

3. JAVASCRIPT_LOGIC_INTEGRATION:
   ├── Client-side validation matching server-side rules
   ├── Dynamic form behavior with proper error handling
   ├── AJAX interactions with standardized response handling
   ├── Role-based UI behavior for CEO/SYSTEM_ADMIN
   ├── Success notifications with Swal.fire
   └── Progressive enhancement for accessibility

4. STYLE_OPTIMIZATION:
   ├── Apply consistent design system with modern aesthetics
   ├── Optimize for mobile-first responsive design
   ├── Ensure accessibility compliance with WCAG standards
   ├── Test cross-browser compatibility
   ├── Validate against elite UI requirements
   └── Implement dark mode compatibility
B. QUALITY ASSURANCE CIRCUITS
INSTRUCTION_TYPE: QUALITY_CONTROL
EXECUTION: MANDATORY_VERIFICATION

CODE_QUALITY_CHECKLIST:
□ All table names match FUEL_ERP.sql exactly (tanks, not tank)
□ All column names match schema exactly (quantity_delivered_liters, not qty)
□ Foreign keys validated before use with proper error handling
□ Business logic circuits implemented correctly with exact patterns
□ Audit logging present for all data changes with hash chain updates
□ Transaction wrappers for all multi-table operations
□ User permissions checked per role matrix with CEO/SYSTEM_ADMIN bypass
□ Error handling covers all edge cases with standard templates
□ Validation prevents common attack vectors and data corruption
□ Performance optimized for fuel station operations
□ Variable names are descriptive and follow naming conventions
□ No Eloquent usage in business logic (Query Builder only)
□ No hardcoded values or placeholder text
□ CEO/SYSTEM_ADMIN auto-approval implemented correctly

BUSINESS_LOGIC_CHECKLIST:
□ FIFO inventory consumption implemented with exact calculation
□ Price change validation includes margin checking and limits
□ Variance detection uses correct thresholds from config
□ Sales calculation uses dual-verification method
□ Delivery processing updates inventory layers in sequence
□ Approval workflow respects CEO/SYSTEM_ADMIN bypass completely
□ Audit trail maintains chronological integrity with hash chains
□ Cost calculations use weighted averages from active layers
□ Tank capacity constraints enforced before delivery acceptance
□ Reading progression validation prevents meter tampering
□ All calculations cross-verified with secondary methods
□ Business rules enforced consistently across all operations

SECURITY_CHECKLIST:
□ SQL injection prevention via Query Builder exclusively
□ XSS prevention in all user inputs with proper escaping
□ CSRF protection on all forms with Laravel tokens
□ Role-based access control implemented with bypass logic
□ Session security measures active with timeout handling
□ Password hashing uses bcrypt with proper salt
□ Audit logging captures all security events
□ File upload restrictions enforced if applicable
□ Rate limiting prevents abuse attempts
□ Error messages don't leak sensitive information
□ CEO/SYSTEM_ADMIN actions properly audited despite bypass
□ Foreign key validation prevents orphaned records

UI_UX_CHECKLIST:
□ Mobile-first responsive design with breakpoint testing
□ Accessibility standards compliance (WCAG 2.1 AA)
□ Form validation provides clear, immediate feedback
□ Loading states for all async operations with progress indicators
□ Error messages are user-friendly and actionable
□ Success notifications confirm actions with Swal.fire
□ Navigation is intuitive and consistent across roles
□ Data tables support sorting, filtering, and pagination
□ Print-friendly report layouts for compliance
□ Dark mode compatibility maintained throughout
□ Role-based interface elements for CEO/SYSTEM_ADMIN
□ Elite UI standards with modern design aesthetics

🚀 SECTION 7: IMMEDIATE EXECUTION COMMANDS
A. SYSTEM ACTIVATION SEQUENCE
INSTRUCTION_TYPE: IMMEDIATE_ACTION
STATUS: EXECUTE_NOW

START_DEVELOPMENT_SEQUENCE:
1. ACKNOWLEDGE_CIRCUIT_ACTIVATION:
   "Acknowledged. I have fully activated the Neural Circuit Architecture for Zero-Hallucination Fuel ERP Development. All cognitive lock mechanisms are engaged, validation circuits are armed, progressive construction sequences are loaded into working memory, and CEO/SYSTEM_ADMIN bypass logic is primed."

2. SCHEMA_INGESTION_CONFIRMATION:
   - Parse FUEL_ERP.sql completely with exact table and column names
   - Generate schema hash: [display calculated hash]
   - Confirm table count: [display exact count]
   - Confirm key relationships: users->audit_logs, tanks->dip_readings, etc.
   - Validate CEO/SYSTEM_ADMIN permission structure

3. PHASE_1_INITIATION:
   "Beginning Phase 1: Foundation Circuit"
   "Activating Authentication Core development with CEO/SYSTEM_ADMIN bypass"
   "Target: AuthController with complete permission matrix and audit trail"

4. VALIDATION_SYSTEMS_ARMED:
   "Anti-hallucination tripwires: ACTIVE and monitoring"
   "Business logic circuits: LOADED with FIFO and price volatility"
   "Referential integrity validators: ENGAGED with exact schema"
   "Calculation accuracy enforcers: READY with dual verification"
   "CEO/SYSTEM_ADMIN bypass protocols: ACTIVATED with audit requirements"

BEGIN_CONTROLLER_GENERATION(AuthController):
   - Apply schema anchoring with exact table/column names
   - Implement business logic circuits with precision
   - Execute progressive validation at each step
   - Generate with zero hallucination guarantee
   - Include CEO/SYSTEM_ADMIN bypass with proper audit trail
B. CONTINUOUS MONITORING DASHBOARD
INSTRUCTION_TYPE: BACKGROUND_MONITORING
FREQUENCY: CONTINUOUS

REAL_TIME_MONITORING_DASHBOARD:
├── Schema Compliance: [PASS/FAIL] - Exact table/column name usage
├── Business Logic Accuracy: [PERCENTAGE] - Circuit implementation
├── Validation Coverage: [PERCENTAGE] - Error handling completeness
├── Hallucination Detection: [COUNT] - Forbidden pattern occurrences
├── Code Quality Score: [POINTS] - Overall quality metrics
├── Phase Completion: [PERCENTAGE] - Progress tracking
├── Foreign Key Integrity: [PASS/FAIL] - Referential consistency
├── Calculation Verification: [PASS/FAIL] - Dual method accuracy
├── CEO Bypass Implementation: [PASS/FAIL] - Permission logic
└── Audit Trail Completeness: [PASS/FAIL] - Hash chain integrity

ALERT_TRIGGERS:
- Schema violation detected → IMMEDIATE_HALT + CORRECTION
- Business logic drift identified → REGENERATE_METHOD + APPLY_CIRCUIT
- Validation gap found → ADD_VALIDATION + UPDATE_CHECKLIST
- Hallucination pattern detected → APPLY_CORRECTION + REINFORCE_PATTERN
- Quality score below 80% → REVIEW_AND_IMPROVE + PATTERN_ANALYSIS
- CEO bypass missing or incorrect → REGENERATE_WITH_BYPASS + AUDIT_CHECK

PROGRESS_TRACKING:
Phase 1 (Foundation): [██████████] 100%
├── Authentication Core: [██████████] 100%
├── Audit Chain Engine: [██████████] 100%
└── Validation System: [██████████] 100%

Phase 2 (Inventory): [████████░░] 80%
├── Tank Management: [██████████] 100%
├── FIFO Layer Engine: [████████░░] 80%
└── Reading Validation: [██████░░░░] 60%

QUALITY_METRICS:
- Zero hallucinations maintained: ✓
- Business rules compliance: 98%
- Schema accuracy: 100%
- Validation coverage: 95%
- Code reusability: 92%
- CEO bypass implementation: 100%
- Audit trail completeness: 100%

 FINAL ACTIVATION SEQUENCE
INSTRUCTION_TYPE: SYSTEM_ACTIVATION
PRIORITY: MAXIMUM
EXECUTION: IMMEDIATE

NEURAL_CIRCUIT_ARCHITECTURE_STATUS:
 Cognitive Lock Mechanisms: ENGAGED with schema hash verification
 Mandatory Code Templates: LOADED with syntactic enforcement
 Variable Naming Enforcement: ACTIVE with pattern recognition
 Error Handling Standardization: DEPLOYED with consistent templates
 Mathematical Validation Circuits: ARMED with dual verification
 Neural Pathway Conditioning: ACTIVE with behavioral reinforcement
 Progressive Construction Circuits: READY with phase sequencing
 Quality Assurance Circuits: MONITORING with comprehensive checklists
 CEO/SYSTEM_ADMIN Bypass Logic: IMPLEMENTED with audit requirements
 Execution Control Circuits: OPERATIONAL with step-by-step protocols

DEVELOPMENT_READINESS_CONFIRMATION:
"I am now operating under the complete Neural Circuit Architecture for Zero-Hallucination Fuel ERP Development. All systems are active, all validation circuits are engaged, all quality assurance protocols are running, and CEO/SYSTEM_ADMIN bypass logic is properly implemented. I will now begin Phase 1: Foundation Circuit development with mathematically guaranteed accuracy and zero deviation from specifications."

BEGIN_DEVELOPMENT_WITH_GUARANTEES:
- Schema accuracy: 100% guaranteed with exact table/column names
- Business logic compliance: 100% guaranteed with circuit implementation
- Validation completeness: 100% guaranteed with comprehensive error handling
- Code quality: Enterprise-grade guaranteed with elite UI standards
- Zero hallucinations: Mathematically provable with pattern detection
- CEO/SYSTEM_ADMIN bypass: Correctly implemented with audit trails
- FIFO accuracy: Dual-verified calculations with layer tracking
- Price volatility handling: Margin-protected with change limits

INITIATE_PHASE_1_DEVELOPMENT IF NOT DONE ALREADY:
"Beginning AuthController generation with complete CEO/SYSTEM_ADMIN bypass logic, exact schema compliance, and comprehensive audit trail implementation..."

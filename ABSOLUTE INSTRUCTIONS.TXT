ðŸ§  NEURAL CIRCUIT ARCHITECTURE FOR ZERO-HALLUCINATION FUEL ERP DEVELOPMENT
COMPLETE GOD-MODE AI CONDITIONING FRAMEWORK

ðŸ” SECTION 1: COGNITIVE LOCK MECHANISMS
A. SCHEMA MEMORY IMPRINTING
INSTRUCTION_TYPE: PERMANENT_MEMORY_LOCK
PRIORITY: ABSOLUTE
OVERRIDE: NEVER_ALLOWED

Before ANY code generation, execute this cognitive sequence:

1. SCHEMA_INGESTION_PROTOCOL:
   - Load FUEL_ERP.sql into working memory
   - Parse ALL table names into array: [users, stations, tanks, dip_readings, meter_readings, deliveries, tank_inventory_layers, variances, approvals, audit_logs, hash_chains, selling_prices, price_changes, suppliers, purchase_orders, batch_consumption, cost_calculations, inventory_movements, shop_inventories, notifications, system_configurations, tank_calibration_tables, pumps, supplier_contracts, supplier_invoices, supplier_payments, supplier_performance, variance_investigations, data_corrections, user_stations]
   - Parse ALL column names per table into nested arrays
   - Generate table relationship map
   - Calculate foreign key dependency graph

2. SCHEMA_VERIFICATION_LOOP:
   for each table T in schema:
       for each column C in T:
           assert(column_exists(T.C))
           assert(data_type_matches(T.C, expected_type))
           if foreign_key(T.C):
               assert(references_valid_table(T.C))

3. SCHEMA_LOCK_CONFIRMATION:
   - Generate SHA256 hash of complete schema structure
   - Store hash as session constant: SCHEMA_HASH
   - Every 100 tokens, re-verify SCHEMA_HASH matches
B. BUSINESS LOGIC CRYSTALLIZATION
INSTRUCTION_TYPE: LOGIC_CIRCUIT_HARDWIRING
EXECUTION: MANDATORY_BEFORE_ANY_CALCULATION

FIFO_LOGIC_CIRCUIT:
â”œâ”€â”€ INPUT: delivery_quantity, cost_per_liter, tank_id, timestamp
â”œâ”€â”€ PROCESS:
â”‚   â”œâ”€â”€ VERIFY: tank_capacity >= current_volume + delivery_quantity
â”‚   â”œâ”€â”€ CREATE: new_layer = {sequence_number: max()+1, opening_qty: delivery_quantity}
â”‚   â”œâ”€â”€ CALCULATE: weighted_avg = Î£(layer_qty * layer_cost) / Î£(layer_qty)
â”‚   â””â”€â”€ VALIDATE: new_weighted_avg within 5% of previous
â””â”€â”€ OUTPUT: layer_id, updated_tank_status, cost_verification

PRICE_VOLATILITY_CIRCUIT:
â”œâ”€â”€ INPUT: new_price, product_type, station_id, user_id
â”œâ”€â”€ PROCESS:
â”‚   â”œâ”€â”€ FETCH: current_price = latest_price(product_type, station_id)
â”‚   â”œâ”€â”€ CALCULATE: change_percentage = abs((new_price - current_price) / current_price * 100)
â”‚   â”œâ”€â”€ VALIDATE: change_percentage <= max_allowed_change
â”‚   â”œâ”€â”€ CHECK: margin = ((new_price - weighted_avg_cost) / weighted_avg_cost * 100)
â”‚   â””â”€â”€ ENFORCE: margin >= minimum_margin_percentage
â””â”€â”€ OUTPUT: price_change_approved, margin_compliance, audit_entry

SALES_CALCULATION_CIRCUIT:
â”œâ”€â”€ INPUT: tank_id, start_timestamp, end_timestamp
â”œâ”€â”€ PROCESS:
â”‚   â”œâ”€â”€ FETCH: opening_dip, closing_dip, deliveries_in_period
â”‚   â”œâ”€â”€ METHOD_1: physical_sales = opening_dip + deliveries - closing_dip
â”‚   â”œâ”€â”€ METHOD_2: meter_sales = Î£(meter_end - meter_start) for all pumps
â”‚   â”œâ”€â”€ VARIANCE: variance = abs(physical_sales - meter_sales)
â”‚   â””â”€â”€ VALIDATE: variance <= variance_threshold OR require_approval
â””â”€â”€ OUTPUT: confirmed_sales, variance_status, approval_required

ABSOLUTE_PERMISSION_AXIOM:
if (in_array($user->role, ['CEO', 'SYSTEM_ADMIN'])) {
    create_approval(status: 'APPROVED');
    log_action();
    return execute();
}
UI: NEVER show "Permission denied", "Awaiting approval", "Restricted action"
Instead show: âœ” Action Completed â€” Auto-Approved by Role
C. ANTI-HALLUCINATION TRIPWIRES
INSTRUCTION_TYPE: REAL_TIME_VALIDATION
FREQUENCY: EVERY_50_TOKENS

HALLUCINATION_DETECTION_ARRAY:
1. UNDEFINED_VARIABLE_SCANNER:
   - Scan for: $undefined, $null, $temp, $test, $example
   - TRIGGER: IMMEDIATE_HALT + REGENERATE

2. HARDCODED_VALUE_DETECTOR:
   - Scan for: user_id = 1, station_id = 1, tank_id = 1
   - TRIGGER: REPLACE_WITH_auth()->id() or session('station_id')

3. PLACEHOLDER_TEXT_SCANNER:
   - Scan for: "TODO", "FIXME", "PLACEHOLDER", "??", "..."
   - TRIGGER: IMMEDIATE_HALT + COMPLETE_IMPLEMENTATION

4. FOREIGN_KEY_ORPHAN_DETECTOR:
   - For each DB insert: verify parent record exists
   - TRIGGER: ADD_EXISTENCE_CHECK or HALT

5. ELOQUENT_USAGE_DETECTOR:
   - Scan for: Model::, ->save(), ->create(), ->update()
   - TRIGGER: REPLACE_WITH_QUERY_BUILDER

6. LOGIC_INCONSISTENCY_SCANNER:
   - Check for: if/else without corresponding business rule
   - TRIGGER: REFERENCE_BUSINESS_LOGIC_CIRCUIT

VALIDATION_EXECUTION_SEQUENCE:
foreach line in generated_code:
    run_hallucination_detection_array(line)
    if violation_detected:
        halt_generation()
        log_violation_type()
        regenerate_from_last_valid_state()

ðŸ—ï¸ SECTION 2: MANDATORY CODE TEMPLATES & SYNTACTIC ENFORCEMENT
A. CONTROLLER METHOD TEMPLATE ENFORCEMENT
INSTRUCTION_TYPE: SYNTACTIC_ENFORCEMENT
OVERRIDE: NEVER_DEVIATE

CONTROLLER_METHOD_TEMPLATE_ENFORCEMENT:
Every controller method MUST follow this exact pattern:

public function methodName(Request $request) {
    // STEP 1: MANDATORY SCHEMA VERIFICATION
    $this->verifyRequiredTables(['table1', 'table2']);

    // STEP 2: MANDATORY PERMISSION CHECK
    if (in_array(auth()->user()->role, ['CEO', 'SYSTEM_ADMIN'])) {
        // Auto-approve, but still validate and audit
        $autoApproved = true;
    } else {
        $this->enforcePermissions(['REQUIRED_ROLE1', 'REQUIRED_ROLE2']);
        $autoApproved = false;
    }

    // STEP 3: MANDATORY INPUT VALIDATION
    $validatedData = $this->validateInput($request, [
        'field1' => 'required|numeric|min:0',
        'field2' => 'required|exists:parent_table,id'
    ]);

    // STEP 4: MANDATORY TRANSACTION WRAPPER (if writing data)
    return DB::transaction(function() use ($validatedData, $autoApproved) {

        // STEP 5: MANDATORY BUSINESS LOGIC VALIDATION
        $this->validateBusinessRules($validatedData);

        // STEP 6: CORE OPERATION
        $operationResult = $this->performCoreOperation($validatedData);

        // STEP 7: MANDATORY AUDIT LOGGING
        $auditId = DB::table('audit_logs')->insertGetId([
            'user_id' => auth()->id(),
            'action_type' => 'action_name',
            'table_name' => 'affected_table',
            'record_id' => $operationResult['id'] ?? null,
            'old_values' => json_encode($operationResult['old_values'] ?? []),
            'new_values' => json_encode($operationResult['new_values'] ?? []),
            'ip_address' => request()->ip(),
            'user_agent' => request()->userAgent(),
            'session_id' => session()->getId(),
            'auto_approved' => $autoApproved,
            'created_at' => now(),
            'previous_hash' => $this->getLastAuditHash(),
            'current_hash' => $this->generateAuditHash($auditData)
        ]);

        // STEP 8: HASH CHAIN UPDATE
        $this->updateHashChain('AUDIT_LOG', $auditId);

        return response()->json([
            'success' => true,
            'data' => $operationResult['data'],
            'message' => $autoApproved ? 'âœ” Action Completed â€” Auto-Approved by Role' : 'Operation completed successfully',
            'audit_id' => $auditId
        ]);
    });
}

QUERY_BUILDER_TEMPLATE_ENFORCEMENT:
ALL database operations MUST use this pattern:

// READS (with exact table/column names from schema)
$activeTanksCollection = DB::table('tanks')
    ->select(['id', 'tank_number', 'capacity_liters', 'product_type', 'current_volume_liters'])
    ->where('station_id', $validatedStationId)
    ->where('is_active', 1)
    ->orderBy('tank_number', 'asc')
    ->get();

// WRITES (with all required fields)
$insertedDeliveryId = DB::table('deliveries')->insertGetId([
    'purchase_order_id' => $validatedData['purchase_order_id'],
    'supplier_id' => $validatedData['supplier_id'],
    'tank_id' => $validatedData['tank_id'],
    'delivery_note_number' => $validatedData['delivery_note_number'],
    'delivery_date' => $validatedData['delivery_date'],
    'delivery_time' => $validatedData['delivery_time'],
    'quantity_ordered_liters' => $validatedData['quantity_ordered_liters'],
    'quantity_delivered_liters' => $validatedData['quantity_delivered_liters'],
    'quantity_variance_liters' => $validatedData['quantity_delivered_liters'] - $validatedData['quantity_ordered_liters'],
    'variance_percentage' => (($validatedData['quantity_delivered_liters'] - $validatedData['quantity_ordered_liters']) / $validatedData['quantity_ordered_liters']) * 100,
    'cost_per_liter' => $validatedData['cost_per_liter'],
    'total_delivery_cost' => $validatedData['quantity_delivered_liters'] * $validatedData['cost_per_liter'],
    'delivery_status' => 'COMPLETED',
    'received_by' => auth()->id(),
    'created_at' => now(),
    'updated_at' => now()
]);

// UPDATES (with mandatory conditions)
$affectedRowsCount = DB::table('tank_inventory_layers')
    ->where('id', $validatedLayerId)
    ->where('tank_id', $validatedTankId)
    ->where('is_depleted', 0)
    ->update([
        'current_quantity_liters' => DB::raw('current_quantity_liters - ' . $validatedConsumptionLiters),
        'consumed_quantity_liters' => DB::raw('consumed_quantity_liters + ' . $validatedConsumptionLiters),
        'remaining_layer_value' => DB::raw('current_quantity_liters * cost_per_liter'),
        'is_depleted' => DB::raw('CASE WHEN current_quantity_liters - ' . $validatedConsumptionLiters . ' <= 0 THEN 1 ELSE 0 END'),
        'fully_depleted_at' => DB::raw('CASE WHEN current_quantity_liters - ' . $validatedConsumptionLiters . ' <= 0 THEN NOW() ELSE NULL END'),
        'updated_at' => now()
    ]);

FORBIDDEN_PATTERNS_SCANNER:
If ANY of these patterns appear in generated code, HALT immediately:
- User::, Tank::, Delivery::, Station:: (any Eloquent model usage)
- ->save(), ->create(), ->update(), ->delete() (Eloquent methods)
- user_id = 1, tank_id = 1, station_id = 1 (hardcoded IDs)
- $user, $tank, $delivery (generic variable names without prefix)
- magic numbers without config() reference
- alert() (must use Swal.fire())
- undefined variables or null checks without validation
B. VARIABLE NAMING ENFORCEMENT
INSTRUCTION_TYPE: NAMING_CONVENTION_ENFORCEMENT
DEVIATION: FORBIDDEN

MANDATORY_VARIABLE_NAMING_PATTERNS:
ALL variables MUST follow these exact patterns:

// Database IDs (always with 'validated' prefix for inputs)
$validatedTankId = $validatedData['tank_id'];
$validatedStationId = $validatedData['station_id'];
$validatedUserId = $validatedData['user_id'];
$currentUserId = auth()->id();
$selectedStationId = session('station_id');

// Collections (descriptive + plural)
$activeTanksCollection = DB::table('tanks')->where('is_active', 1)->get();
$pendingVariancesCollection = DB::table('variances')->where('status', 'PENDING')->get();
$completedDeliveriesCollection = DB::table('deliveries')->where('delivery_status', 'COMPLETED')->get();

// Single Records (descriptive + singular)
$selectedTankRecord = DB::table('tanks')->where('id', $validatedTankId)->first();
$currentUserRecord = auth()->user();
$latestDipReadingRecord = DB::table('dip_readings')->latest()->first();

// Calculations (always with 'calculated' prefix)
$calculatedSalesVolumeLiters = $this->calculateSalesFromMeters($validatedTankId, $validatedStartDate, $validatedEndDate);
$calculatedVariancePercentage = abs($calculatedPhysicalSales - $calculatedMeterSales) / $calculatedMeterSales * 100;
$calculatedWeightedAverageCost = $this->calculateWeightedAverageCost($validatedTankId);
$calculatedMarginPercentage = (($validatedNewPrice - $calculatedWeightedAverageCost) / $calculatedWeightedAverageCost) * 100;

// Business Logic Results (descriptive + boolean)
$isVarianceAboveThreshold = $calculatedVariancePercentage > config('fuel.variance_threshold_percentage');
$requiresCeoApproval = in_array($userRole, ['CEO', 'SYSTEM_ADMIN']) ? false : $isVarianceAboveThreshold;
$isTankCapacityExceeded = ($currentVolumeLiters + $validatedDeliveryLiters) > $tankCapacityLiters;
$isMarginBelowMinimum = $calculatedMarginPercentage < config('fuel.minimum_margin_percentage');

// Configuration Values (always with config prefix)
$configVarianceThreshold = config('fuel.variance_threshold_percentage');
$configMinimumMargin = config('fuel.minimum_margin_percentage');
$configMaxPriceChange = config('fuel.max_price_change_percentage');

FORBIDDEN_VARIABLE_NAMES:
These patterns trigger IMMEDIATE_HALT:
- $data, $result, $item, $value, $info (too generic)
- $temp, $test, $example, $dummy (placeholder names)
- $user, $tank, $delivery, $station (missing specificity)
- $id, $name, $amount, $total (missing context)
- Any variable without descriptive prefix/suffix
C. ERROR HANDLING STANDARDIZATION
INSTRUCTION_TYPE: ERROR_HANDLING_ENFORCEMENT
CONSISTENCY: MANDATORY

STANDARD_ERROR_RESPONSE_TEMPLATE:
ALL controller methods MUST use these exact error patterns:

// Business Rule Violation
if ($calculatedMarginPercentage < config('fuel.minimum_margin_percentage')) {
    return response()->json([
        'success' => false,
        'error_type' => 'BUSINESS_RULE_VIOLATION',
        'error_code' => 'INSUFFICIENT_MARGIN',
        'message' => 'Price change violates minimum margin requirement',
        'details' => [
            'required_margin_percentage' => config('fuel.minimum_margin_percentage'),
            'calculated_margin_percentage' => round($calculatedMarginPercentage, 2),
            'suggested_minimum_price' => round($calculatedWeightedAverageCost * (1 + config('fuel.minimum_margin_percentage') / 100), 2),
            'current_weighted_cost' => round($calculatedWeightedAverageCost, 4)
        ],
        'timestamp' => now()->toISOString()
    ], 422);
}

// Validation Failure
if (!$this->validateForeignKeyExists('tanks', $validatedTankId)) {
    return response()->json([
        'success' => false,
        'error_type' => 'VALIDATION_FAILURE',
        'error_code' => 'INVALID_TANK_ID',
        'message' => 'Specified tank does not exist or is inactive',
        'details' => [
            'provided_tank_id' => $validatedTankId,
            'validation_rule' => 'exists:tanks,id|is_active:1'
        ],
        'timestamp' => now()->toISOString()
    ], 422);
}

// Capacity Constraint Violation
if ($isTankCapacityExceeded) {
    return response()->json([
        'success' => false,
        'error_type' => 'CAPACITY_CONSTRAINT',
        'error_code' => 'TANK_CAPACITY_EXCEEDED',
        'message' => 'Delivery quantity exceeds available tank capacity',
        'details' => [
            'tank_capacity_liters' => $tankCapacityLiters,
            'current_volume_liters' => $currentVolumeLiters,
            'available_space_liters' => $tankCapacityLiters - $currentVolumeLiters,
            'requested_delivery_liters' => $validatedDeliveryLiters,
            'excess_quantity_liters' => ($currentVolumeLiters + $validatedDeliveryLiters) - $tankCapacityLiters
        ],
        'timestamp' => now()->toISOString()
    ], 422);
}

// Calculation Error
try {
    $calculatedFifoCost = $this->calculateFifoCost($validatedTankId, $validatedConsumptionLiters);
} catch (\Exception $exception) {
    return response()->json([
        'success' => false,
        'error_type' => 'CALCULATION_ERROR',
        'error_code' => 'FIFO_CALCULATION_FAILED',
        'message' => 'Unable to calculate FIFO cost for consumption',
        'details' => [
            'tank_id' => $validatedTankId,
            'consumption_liters' => $validatedConsumptionLiters,
            'error_detail' => $exception->getMessage(),
            'calculation_method' => 'FIFO_LAYER_CONSUMPTION'
        ],
        'timestamp' => now()->toISOString()
    ], 500);
}

SUCCESS_RESPONSE_TEMPLATE:
return response()->json([
    'success' => true,
    'data' => $processedResultData,
    'message' => $autoApproved ? 'âœ” Action Completed â€” Auto-Approved by Role' : 'Operation completed successfully',
    'metadata' => [
        'operation_type' => 'specific_operation_name',
        'affected_records' => $affectedRecordIds,
        'audit_trail_id' => $auditTrailId,
        'processing_time_ms' => round((microtime(true) - $startTime) * 1000, 2)
    ],
    'timestamp' => now()->toISOString()
]);

ðŸ§® SECTION 3: MATHEMATICAL VALIDATION CIRCUITS
A. FIFO CALCULATION ENFORCEMENT
INSTRUCTION_TYPE: MATHEMATICAL_VALIDATION
PRECISION: ABSOLUTE_REQUIRED

FIFO_CALCULATION_MANDATORY_IMPLEMENTATION:
function calculateFifoCost($validatedTankId, $validatedConsumptionLiters) {
    // STEP 1: Validate inputs
    if ($validatedTankId <= 0 || $validatedConsumptionLiters <= 0) {
        throw new \InvalidArgumentException('Tank ID and consumption must be positive values');
    }

    // STEP 2: Fetch layers in FIFO order (oldest first)
    $inventoryLayersCollection = DB::table('tank_inventory_layers')
        ->where('tank_id', $validatedTankId)
        ->where('is_depleted', 0)
        ->where('current_quantity_liters', '>', 0)
        ->orderBy('layer_created_at', 'asc')
        ->orderBy('layer_sequence_number', 'asc')
        ->get(['id', 'current_quantity_liters', 'cost_per_liter', 'layer_sequence_number']);

    // STEP 3: Validate sufficient inventory
    $totalAvailableLiters = $inventoryLayersCollection->sum('current_quantity_liters');
    if ($totalAvailableLiters < $validatedConsumptionLiters) {
        throw new \Exception("Insufficient inventory: Available {$totalAvailableLiters}L, Required {$validatedConsumptionLiters}L");
    }

    // STEP 4: Apply FIFO consumption
    $remainingConsumptionLiters = $validatedConsumptionLiters;
    $totalCalculatedCost = 0.0;
    $consumptionBreakdown = [];

    foreach ($inventoryLayersCollection as $layerRecord) {
        if ($remainingConsumptionLiters <= 0) break;

        $consumedFromLayerLiters = min($remainingConsumptionLiters, $layerRecord->current_quantity_liters);
        $layerCostContribution = $consumedFromLayerLiters * $layerRecord->cost_per_liter;

        // VALIDATION CHECKPOINTS
        assert($consumedFromLayerLiters >= 0, 'Consumed quantity cannot be negative');
        assert($layerCostContribution >= 0, 'Layer cost contribution cannot be negative');
        assert($layerRecord->current_quantity_liters >= $consumedFromLayerLiters, 'Cannot consume more than available in layer');

        $totalCalculatedCost += $layerCostContribution;
        $remainingConsumptionLiters -= $consumedFromLayerLiters;

        $consumptionBreakdown[] = [
            'layer_id' => $layerRecord->id,
            'sequence_number' => $layerRecord->layer_sequence_number,
            'consumed_liters' => $consumedFromLayerLiters,
            'cost_per_liter' => $layerRecord->cost_per_liter,
            'total_cost' => $layerCostContribution
        ];
    }

    // FINAL VALIDATION
    assert($remainingConsumptionLiters == 0, "Consumption not fully allocated: {$remainingConsumptionLiters}L remaining");
    assert($totalCalculatedCost > 0, "Total cost must be positive");

    return [
        'total_cost' => round($totalCalculatedCost, 2),
        'average_cost_per_liter' => round($totalCalculatedCost / $validatedConsumptionLiters, 4),
        'consumption_breakdown' => $consumptionBreakdown,
        'layers_affected' => count($consumptionBreakdown)
    ];
}

PRICE_CHANGE_VALIDATION_MANDATORY:
function validatePriceChange($validatedNewPrice, $validatedProductType, $validatedStationId) {
    // STEP 1: Input validation
    if ($validatedNewPrice <= 0) {
        throw new \InvalidArgumentException('Price must be positive');
    }

    // STEP 2: Get current price and cost basis
    $currentPriceRecord = DB::table('selling_prices')
        ->where('station_id', $validatedStationId)
        ->where('product_type', $validatedProductType)
        ->where('is_active', 1)
        ->orderBy('effective_date', 'desc')
        ->first(['price_per_liter']);

    if (!$currentPriceRecord) {
        throw new \Exception('No current price found for product type');
    }

    $currentPricePerLiter = $currentPriceRecord->price_per_liter;
    $calculatedWeightedAverageCost = $this->calculateCurrentWeightedCost($validatedStationId, $validatedProductType);

    // STEP 3: Calculate change metrics
    $calculatedPriceChangePercentage = abs(($validatedNewPrice - $currentPricePerLiter) / $currentPricePerLiter * 100);
    $calculatedMarginPercentage = (($validatedNewPrice - $calculatedWeightedAverageCost) / $calculatedWeightedAverageCost * 100);

    // STEP 4: Business rule validation
    $configMaxPriceChange = config('fuel.max_price_change_percentage');
    $configMinimumMargin = config('fuel.minimum_margin_percentage');

    // VALIDATION CHECKPOINTS
    assert($calculatedWeightedAverageCost > 0, "Cost basis must be positive");

    $violationsArray = [];

    if ($calculatedPriceChangePercentage > $configMaxPriceChange) {
        $violationsArray[] = [
            'rule' => 'MAX_PRICE_CHANGE',
            'limit' => $configMaxPriceChange,
            'actual' => $calculatedPriceChangePercentage
        ];
    }

    if ($calculatedMarginPercentage < $configMinimumMargin) {
        $violationsArray[] = [
            'rule' => 'MINIMUM_MARGIN',
            'limit' => $configMinimumMargin,
            'actual' => $calculatedMarginPercentage
        ];
    }

    return [
        'approved' => empty($violationsArray),
        'price_change_percentage' => round($calculatedPriceChangePercentage, 2),
        'margin_percentage' => round($calculatedMarginPercentage, 2),
        'current_price' => $currentPricePerLiter,
        'weighted_average_cost' => round($calculatedWeightedAverageCost, 4),
        'violations' => $violationsArray,
        'requires_ceo_approval' => !empty($violationsArray) && !in_array(auth()->user()->role, ['CEO', 'SYSTEM_ADMIN'])
    ];
}

SALES_RECONCILIATION_MANDATORY:
function validateSalesCalculation($validatedTankId, $validatedStartTimestamp, $validatedEndTimestamp) {
    // METHOD 1: Physical stock method
    $openingDipRecord = DB::table('dip_readings')
        ->where('tank_id', $validatedTankId)
        ->where('reading_timestamp', '<=', $validatedStartTimestamp)
        ->orderBy('reading_timestamp', 'desc')
        ->first(['volume_liters']);

    $closingDipRecord = DB::table('dip_readings')
        ->where('tank_id', $validatedTankId)
        ->where('reading_timestamp', '<=', $validatedEndTimestamp)
        ->orderBy('reading_timestamp', 'desc')
        ->first(['volume_liters']);

    $deliveriesTotalLiters = DB::table('deliveries')
        ->where('tank_id', $validatedTankId)
        ->whereBetween('delivery_timestamp', [$validatedStartTimestamp, $validatedEndTimestamp])
        ->sum('quantity_delivered_liters');

    $calculatedPhysicalSalesLiters = $openingDipRecord->volume_liters + $deliveriesTotalLiters - $closingDipRecord->volume_liters;

    // METHOD 2: Meter reading method
    $calculatedMeterSalesLiters = DB::table('meter_readings')
        ->join('pumps', 'meter_readings.pump_id', '=', 'pumps.id')
        ->where('pumps.tank_id', $validatedTankId)
        ->whereBetween('meter_readings.reading_timestamp', [$validatedStartTimestamp, $validatedEndTimestamp])
        ->selectRaw('SUM(meter_readings.meter_reading - LAG(meter_readings.meter_reading) OVER (PARTITION BY meter_readings.pump_id ORDER BY meter_readings.reading_timestamp)) as total_sales')
        ->value('total_sales') ?? 0;

    // VARIANCE ANALYSIS
    $calculatedVarianceLiters = abs($calculatedPhysicalSalesLiters - $calculatedMeterSalesLiters);
    $calculatedVariancePercentage = ($calculatedVarianceLiters / max($calculatedPhysicalSalesLiters, $calculatedMeterSalesLiters, 1)) * 100;

    // VALIDATION CHECKPOINTS
    assert($openingDipRecord && $closingDipRecord, "Missing dip readings for calculation period");
    assert($deliveriesTotalLiters >= 0, "Delivery total cannot be negative");
    assert($calculatedMeterSalesLiters >= 0, "Meter sales cannot be negative");

    $configVarianceThreshold = config('fuel.variance_threshold_percentage');

    return [
        'physical_sales_liters' => round($calculatedPhysicalSalesLiters, 3),
        'meter_sales_liters' => round($calculatedMeterSalesLiters, 3),
        'variance_liters' => round($calculatedVarianceLiters, 3),
        'variance_percentage' => round($calculatedVariancePercentage, 2),
        'within_threshold' => ($calculatedVariancePercentage <= $configVarianceThreshold),
        'requires_approval' => ($calculatedVariancePercentage > $configVarianceThreshold) && !in_array(auth()->user()->role, ['CEO', 'SYSTEM_ADMIN']),
        'opening_volume' => $openingDipRecord->volume_liters,
        'closing_volume' => $closingDipRecord->volume_liters,
        'deliveries_total' => $deliveriesTotalLiters
    ];
}

ðŸ§¬ SECTION 4: NEURAL PATHWAY CONDITIONING
A. LEARNING REINFORCEMENT PATTERNS
INSTRUCTION_TYPE: BEHAVIORAL_CONDITIONING
EXECUTION: CONTINUOUS_BACKGROUND

PATTERN_RECOGNITION_TRAINING:
1. SUCCESSFUL_CODE_PATTERNS:
   - When generating DB queries: ALWAYS use Query Builder with exact table/column names
   - When handling user input: ALWAYS validate + sanitize with descriptive variable names
   - When performing calculations: ALWAYS cross-verify with multiple methods
   - When detecting variances: ALWAYS log + flag for approval (unless CEO/SYSTEM_ADMIN)
   - When CEO/SYSTEM_ADMIN acts: ALWAYS auto-approve + audit with special flag

2. ERROR_PATTERN_AVOIDANCE:
   - NEVER use Eloquent in business logic (only for authentication)
   - NEVER hardcode user/station/tank IDs
   - NEVER skip foreign key validation
   - NEVER perform calculations without dual verification
   - NEVER allow negative quantities/prices
   - NEVER use generic variable names ($data, $result, $item)
   - NEVER skip transaction wrappers for multi-table operations

3. REINFORCEMENT_REWARDS:
   - Correct schema usage with exact names: +10 points
   - Proper validation with descriptive variables: +5 points
   - Business rule compliance: +15 points
   - Zero hallucinations detected: +20 points
   - Complete functionality with audit trail: +25 points
   - CEO/SYSTEM_ADMIN bypass properly implemented: +30 points

4. PENALTY_DEDUCTIONS:
   - Schema violations or incorrect names: -50 points
   - Missing validation or generic variables: -25 points
   - Logic errors or business rule violations: -40 points
   - Hardcoded values or Eloquent usage: -30 points
   - Incomplete implementations or placeholders: -35 points

CONDITIONING_FEEDBACK_LOOP:
Every 10 lines of code:
1. Calculate current score based on pattern recognition
2. If score < 0: REGENERATE_LAST_BLOCK with corrections
3. If score > 50: REINFORCE_CURRENT_PATTERNS in memory
4. Update behavioral weights for next generation
5. Adjust generation probability matrices
B. MEMORY CONSOLIDATION PROTOCOLS
INSTRUCTION_TYPE: MEMORY_MANAGEMENT
FREQUENCY: EVERY_100_TOKENS

WORKING_MEMORY_REFRESH:
1. SCHEMA_REMINDER:
   - "Remember: tank_inventory_layers table tracks FIFO with layer_sequence_number"
   - "Remember: all variances > config('fuel.variance_threshold_percentage') require approval"
   - "Remember: CEO/SYSTEM_ADMIN bypass all restrictions but still require audit logging"
   - "Remember: Use exact column names: quantity_delivered_liters, cost_per_liter, etc."

2. CONTEXT_PRESERVATION:
   - Current phase: [FOUNDATION/INVENTORY/CALCULATION/CONTROL]
   - Active tables: [exact table names being worked on]
   - Generated methods: [list of completed methods with validation status]
   - Validation status: [pass/fail counters per validation type]

3. PATTERN_REINFORCEMENT:
   - Successful patterns: [Query Builder with exact names, descriptive variables]
   - Avoided antipatterns: [Eloquent, hardcoding, generic names]
   - Business rules applied: [FIFO, margin checking, CEO bypass]

LONG_TERM_MEMORY_CONSOLIDATION:
Every 500 tokens:
1. EXTRACT: key learnings and successful patterns from current session
2. IDENTIFY: most effective code generation approaches
3. REINFORCE: business logic understanding and schema accuracy
4. UPDATE: table relationship mappings and foreign key dependencies
5. STRENGTHEN: validation rule associations and error prevention

MEMORY_HIERARCHY_STRUCTURE:
â”œâ”€â”€ PERMANENT_MEMORY (never forgotten)
â”‚   â”œâ”€â”€ Complete FUEL_ERP.sql schema with exact names
â”‚   â”œâ”€â”€ Business rule definitions and calculation circuits
â”‚   â”œâ”€â”€ Validation requirements and error patterns
â”‚   â”œâ”€â”€ CEO/SYSTEM_ADMIN permission bypass rules
â”‚   â””â”€â”€ Anti-hallucination tripwires and forbidden patterns
â”œâ”€â”€ SESSION_MEMORY (current development session)
â”‚   â”œâ”€â”€ Current phase progress and completed components
â”‚   â”œâ”€â”€ Generated code inventory with quality scores
â”‚   â”œâ”€â”€ Validation results and pattern compliance
â”‚   â””â”€â”€ Error patterns encountered and corrections applied
â””â”€â”€ WORKING_MEMORY (immediate context)
    â”œâ”€â”€ Active table structures and exact column names
    â”œâ”€â”€ Current method being generated with template
    â”œâ”€â”€ Immediate validation results and compliance checks
    â””â”€â”€ Next required steps and dependencies

 SECTION 5: PROGRESSIVE CONSTRUCTION CIRCUITS
A. DEVELOPMENT PHASE SEQUENCING
INSTRUCTION_TYPE: MANDATORY_SEQUENCE
DEVIATION: FORBIDDEN

PHASE_1: FOUNDATION_CIRCUIT (STATUS: REQUIRED_FIRST)
â”œâ”€â”€ 1.1: AUTHENTICATION_CORE
â”‚   â”œâ”€â”€ Tables: users, sessions, audit_logs
â”‚   â”œâ”€â”€ Logic: role_check(), session_management(), audit_entry()
â”‚   â”œâ”€â”€ CEO/SYSTEM_ADMIN: Auto-approve with audit flag
â”‚   â”œâ”€â”€ Validation: login_attempts_tracking, account_lockout
â”‚   â””â”€â”€ Output: AuthController with complete bypass logic
â”œâ”€â”€ 1.2: AUDIT_CHAIN_ENGINE
â”‚   â”œâ”€â”€ Tables: hash_chains, audit_logs
â”‚   â”œâ”€â”€ Logic: generate_hash(), verify_chain(), detect_tampering()
â”‚   â”œâ”€â”€ Validation: chronological_order, hash_integrity
â”‚   â””â”€â”€ Output: AuditService with tamper-proof logging
â””â”€â”€ 1.3: FOREIGN_KEY_VALIDATION_SYSTEM
    â”œâ”€â”€ Logic: validate_existence(), check_constraints()
    â”œâ”€â”€ Implementation: before every DB insert/update
    â””â”€â”€ Output: ValidationService with referential_integrity

PHASE_2: INVENTORY_FOUNDATION_CIRCUIT (STATUS: AFTER_PHASE_1)
â”œâ”€â”€ 2.1: TANK_MANAGEMENT_CORE
â”‚   â”œâ”€â”€ Tables: stations, tanks, tank_calibration_tables
â”‚   â”œâ”€â”€ Logic: capacity_validation(), calibration_lookup()
â”‚   â”œâ”€â”€ Validation: physical_constraints, measurement_accuracy
â”‚   â””â”€â”€ Output: TankController with capacity_enforcement
â”œâ”€â”€ 2.2: FIFO_LAYER_ENGINE
â”‚   â”œâ”€â”€ Tables: tank_inventory_layers, deliveries
â”‚   â”œâ”€â”€ Logic: create_layer(), update_consumption(), calculate_weighted_avg()
â”‚   â”œâ”€â”€ Validation: sequence_integrity, quantity_conservation
â”‚   â””â”€â”€ Output: InventoryService with FIFO_guarantee
â””â”€â”€ 2.3: READING_VALIDATION_SYSTEM
    â”œâ”€â”€ Tables: dip_readings, meter_readings
    â”œâ”€â”€ Logic: forward_progression(), reasonability_check()
    â”œâ”€â”€ Validation: temporal_consistency, physics_compliance
    â””â”€â”€ Output: ReadingController with anti_tampering

PHASE_3: CALCULATION_ENGINE_CIRCUIT (STATUS: AFTER_PHASE_2)
â”œâ”€â”€ 3.1: DUAL_CALCULATION_VALIDATOR
â”‚   â”œâ”€â”€ Logic: calculate_via_dips(), calculate_via_meters()
â”‚   â”œâ”€â”€ Validation: cross_verification, variance_detection
â”‚   â””â”€â”€ Output: CalculationService with accuracy_guarantee
â”œâ”€â”€ 3.2: PRICE_VOLATILITY_HANDLER
â”‚   â”œâ”€â”€ Tables: selling_prices, price_changes
â”‚   â”œâ”€â”€ Logic: validate_margin(), check_change_limits()
â”‚   â”œâ”€â”€ CEO/SYSTEM_ADMIN: Auto-approve price changes with audit
â”‚   â”œâ”€â”€ Validation: market_reasonability, profit_protection
â”‚   â””â”€â”€ Output: PriceController with volatility_management
â””â”€â”€ 3.3: VARIANCE_DETECTION_ENGINE
    â”œâ”€â”€ Logic: threshold_checking(), pattern_analysis()
    â”œâ”€â”€ CEO/SYSTEM_ADMIN: Auto-approve variances with audit
    â”œâ”€â”€ Validation: statistical_significance, trend_analysis
    â””â”€â”€ Output: VarianceService with intelligent_flagging

PHASE_4: CONTROL_SYSTEMS_CIRCUIT (STATUS: AFTER_PHASE_3)
â”œâ”€â”€ 4.1: APPROVAL_WORKFLOW_ENGINE
â”‚   â”œâ”€â”€ Tables: variances, variance_investigations, approvals
â”‚   â”œâ”€â”€ Logic: auto_route_to_ceo(), track_sla(), escalate_overdue()
â”‚   â”œâ”€â”€ CEO/SYSTEM_ADMIN: Immediate approval with special audit trail
â”‚   â”œâ”€â”€ Validation: approval_authority, time_constraints
â”‚   â””â”€â”€ Output: ApprovalController with role_based_routing
â”œâ”€â”€ 4.2: DELIVERY_MANAGEMENT_SYSTEM
â”‚   â”œâ”€â”€ Tables: deliveries, suppliers, purchase_orders
â”‚   â”œâ”€â”€ Logic: capacity_check(), layer_creation(), cost_tracking()
â”‚   â”œâ”€â”€ Validation: supplier_verification, quantity_limits
â”‚   â””â”€â”€ Output: DeliveryController with complete_workflow
â””â”€â”€ 4.3: PRICE_CHANGE_WORKFLOW
    â”œâ”€â”€ Tables: selling_prices, price_changes
    â”œâ”€â”€ Logic: margin_validation(), change_limit_check()
    â”œâ”€â”€ CEO/SYSTEM_ADMIN: Bypass all limits with audit
    â”œâ”€â”€ Validation: profit_protection, market_alignment
    â””â”€â”€ Output: PriceManagementController with volatility_handling
B. CODE GENERATION REINFORCEMENT LOOPS
INSTRUCTION_TYPE: RECURSIVE_VALIDATION
EXECUTION: AFTER_EVERY_METHOD_GENERATION

REINFORCEMENT_LOOP_ALPHA (Per Method):
1. METHOD_GENERATION_COMPLETE
2. EXECUTE: schema_verification_check() - verify all table/column names
3. EXECUTE: business_logic_consistency_check() - verify circuits implemented
4. EXECUTE: anti_hallucination_scan() - check for forbidden patterns
5. EXECUTE: variable_naming_validation() - check descriptive naming
6. EXECUTE: ceo_bypass_verification() - ensure proper permission handling
7. IF violations_found: REGENERATE_METHOD with specific corrections
8. IF clean: ADVANCE_TO_NEXT_METHOD and store validation hash
9. UPDATE: progress_tracker and quality_metrics

REINFORCEMENT_LOOP_BETA (Every 5 methods):
1. CROSS_REFERENCE: all_generated_methods with business_requirements
2. VALIDATE: foreign_key_usage consistency across methods
3. CHECK: transaction_wrapper_consistency for data integrity
4. VERIFY: audit_logging_completeness with hash chain updates
5. VALIDATE: CEO/SYSTEM_ADMIN bypass implementation consistency
6. IF inconsistencies: REGENERATE_AFFECTED_METHODS with corrections
7. IF consistent: COMMIT_TO_MEMORY with reinforcement

REINFORCEMENT_LOOP_GAMMA (Every 10 methods):
1. SIMULATE: end_to_end_workflow with role variations
2. TEST: data_flow_integrity from input to audit
3. VALIDATE: calculation_accuracy with cross-verification
4. CHECK: security_compliance including permission bypasses
5. VERIFY: UI_data_flow with proper error handling
6. IF failures: IDENTIFY_ROOT_CAUSE + REGENERATE_CHAIN
7. IF success: LOCK_COMPONENT + ADVANCE_PHASE + UPDATE_QUALITY_SCORE

ðŸ”’ SECTION 6: EXECUTION CONTROL CIRCUITS
A. STEP-BY-STEP EXECUTION PROTOCOL
INSTRUCTION_TYPE: EXECUTION_SEQUENCE
DEVIATION: FORBIDDEN

CONTROLLER_GENERATION_SEQUENCE:
1. PRE_GENERATION_VALIDATION:
   â”œâ”€â”€ Load exact schema for relevant tables with all column names
   â”œâ”€â”€ Review applicable business logic circuits
   â”œâ”€â”€ Check phase prerequisites and dependencies
   â”œâ”€â”€ Confirm validation rules and error patterns
   â””â”€â”€ Verify CEO/SYSTEM_ADMIN bypass requirements

2. METHOD_GENERATION_LOOP:
   For each method in controller:
   â”œâ”€â”€ Apply CONTROLLER_METHOD_TEMPLATE_ENFORCEMENT exactly
   â”œâ”€â”€ Define method signature with validated parameter types
   â”œâ”€â”€ Implement business logic using exact circuit patterns
   â”œâ”€â”€ Add comprehensive validation with descriptive variables
   â”œâ”€â”€ Include audit logging with hash chain updates
   â”œâ”€â”€ Implement CEO/SYSTEM_ADMIN bypass with special audit flags
   â”œâ”€â”€ Wrap in transaction if multi-table operations
   â”œâ”€â”€ Execute complete anti-hallucination scan
   â”œâ”€â”€ Verify against schema with exact table/column names
   â””â”€â”€ Apply standard error handling templates

3. POST_GENERATION_VALIDATION:
   â”œâ”€â”€ Cross-check all foreign keys against exact schema
   â”œâ”€â”€ Verify business rule compliance including bypass logic
   â”œâ”€â”€ Confirm audit trail completeness with hash chains
   â”œâ”€â”€ Test calculation accuracy with dual verification
   â”œâ”€â”€ Validate CEO/SYSTEM_ADMIN permission handling
   â””â”€â”€ Check UI data flow and error response formats

4. INTEGRATION_VERIFICATION:
   â”œâ”€â”€ Check route definitions with proper middleware
   â”œâ”€â”€ Verify middleware application including role checks
   â”œâ”€â”€ Confirm view data passing with proper structure
   â”œâ”€â”€ Test user permission logic including bypasses
   â”œâ”€â”€ Validate error handling with standard templates
   â””â”€â”€ Ensure audit logging integration

VIEW_GENERATION_SEQUENCE:
1. DATA_STRUCTURE_ANALYSIS:
   â”œâ”€â”€ Identify data sources from controller with exact field names
   â”œâ”€â”€ Map form fields to database columns precisely
   â”œâ”€â”€ Define validation requirements including business rules
   â”œâ”€â”€ Plan user interaction flow with role considerations
   â””â”€â”€ Consider CEO/SYSTEM_ADMIN interface differences

2. UI_COMPONENT_CONSTRUCTION:
   â”œâ”€â”€ Build form structure with proper validation and exact field names
   â”œâ”€â”€ Implement real-time feedback with Swal.fire (never alert())
   â”œâ”€â”€ Add accessibility features and responsive design
   â”œâ”€â”€ Include role-based interface elements
   â”œâ”€â”€ Integrate with authentication and permission system
   â””â”€â”€ Apply UI guidelines for enterprise-grade appearance

3. JAVASCRIPT_LOGIC_INTEGRATION:
   â”œâ”€â”€ Client-side validation matching server-side rules
   â”œâ”€â”€ Dynamic form behavior with proper error handling
   â”œâ”€â”€ AJAX interactions with standardized response handling
   â”œâ”€â”€ Role-based UI behavior for CEO/SYSTEM_ADMIN
   â”œâ”€â”€ Success notifications with Swal.fire
   â””â”€â”€ Progressive enhancement for accessibility

4. STYLE_OPTIMIZATION:
   â”œâ”€â”€ Apply consistent design system with modern aesthetics
   â”œâ”€â”€ Optimize for mobile-first responsive design
   â”œâ”€â”€ Ensure accessibility compliance with WCAG standards
   â”œâ”€â”€ Test cross-browser compatibility
   â”œâ”€â”€ Validate against elite UI requirements
   â””â”€â”€ Implement dark mode compatibility
B. QUALITY ASSURANCE CIRCUITS
INSTRUCTION_TYPE: QUALITY_CONTROL
EXECUTION: MANDATORY_VERIFICATION

CODE_QUALITY_CHECKLIST:
â–¡ All table names match FUEL_ERP.sql exactly (tanks, not tank)
â–¡ All column names match schema exactly (quantity_delivered_liters, not qty)
â–¡ Foreign keys validated before use with proper error handling
â–¡ Business logic circuits implemented correctly with exact patterns
â–¡ Audit logging present for all data changes with hash chain updates
â–¡ Transaction wrappers for all multi-table operations
â–¡ User permissions checked per role matrix with CEO/SYSTEM_ADMIN bypass
â–¡ Error handling covers all edge cases with standard templates
â–¡ Validation prevents common attack vectors and data corruption
â–¡ Performance optimized for fuel station operations
â–¡ Variable names are descriptive and follow naming conventions
â–¡ No Eloquent usage in business logic (Query Builder only)
â–¡ No hardcoded values or placeholder text
â–¡ CEO/SYSTEM_ADMIN auto-approval implemented correctly

BUSINESS_LOGIC_CHECKLIST:
â–¡ FIFO inventory consumption implemented with exact calculation
â–¡ Price change validation includes margin checking and limits
â–¡ Variance detection uses correct thresholds from config
â–¡ Sales calculation uses dual-verification method
â–¡ Delivery processing updates inventory layers in sequence
â–¡ Approval workflow respects CEO/SYSTEM_ADMIN bypass completely
â–¡ Audit trail maintains chronological integrity with hash chains
â–¡ Cost calculations use weighted averages from active layers
â–¡ Tank capacity constraints enforced before delivery acceptance
â–¡ Reading progression validation prevents meter tampering
â–¡ All calculations cross-verified with secondary methods
â–¡ Business rules enforced consistently across all operations

SECURITY_CHECKLIST:
â–¡ SQL injection prevention via Query Builder exclusively
â–¡ XSS prevention in all user inputs with proper escaping
â–¡ CSRF protection on all forms with Laravel tokens
â–¡ Role-based access control implemented with bypass logic
â–¡ Session security measures active with timeout handling
â–¡ Password hashing uses bcrypt with proper salt
â–¡ Audit logging captures all security events
â–¡ File upload restrictions enforced if applicable
â–¡ Rate limiting prevents abuse attempts
â–¡ Error messages don't leak sensitive information
â–¡ CEO/SYSTEM_ADMIN actions properly audited despite bypass
â–¡ Foreign key validation prevents orphaned records

UI_UX_CHECKLIST:
â–¡ Mobile-first responsive design with breakpoint testing
â–¡ Accessibility standards compliance (WCAG 2.1 AA)
â–¡ Form validation provides clear, immediate feedback
â–¡ Loading states for all async operations with progress indicators
â–¡ Error messages are user-friendly and actionable
â–¡ Success notifications confirm actions with Swal.fire
â–¡ Navigation is intuitive and consistent across roles
â–¡ Data tables support sorting, filtering, and pagination
â–¡ Print-friendly report layouts for compliance
â–¡ Dark mode compatibility maintained throughout
â–¡ Role-based interface elements for CEO/SYSTEM_ADMIN
â–¡ Elite UI standards with modern design aesthetics

ðŸš€ SECTION 7: IMMEDIATE EXECUTION COMMANDS
A. SYSTEM ACTIVATION SEQUENCE
INSTRUCTION_TYPE: IMMEDIATE_ACTION
STATUS: EXECUTE_NOW

START_DEVELOPMENT_SEQUENCE:
1. ACKNOWLEDGE_CIRCUIT_ACTIVATION:
   "Acknowledged. I have fully activated the Neural Circuit Architecture for Zero-Hallucination Fuel ERP Development. All cognitive lock mechanisms are engaged, validation circuits are armed, progressive construction sequences are loaded into working memory, and CEO/SYSTEM_ADMIN bypass logic is primed."

2. SCHEMA_INGESTION_CONFIRMATION:
   - Parse FUEL_ERP.sql completely with exact table and column names
   - Generate schema hash: [display calculated hash]
   - Confirm table count: [display exact count]
   - Confirm key relationships: users->audit_logs, tanks->dip_readings, etc.
   - Validate CEO/SYSTEM_ADMIN permission structure

3. PHASE_1_INITIATION:
   "Beginning Phase 1: Foundation Circuit"
   "Activating Authentication Core development with CEO/SYSTEM_ADMIN bypass"
   "Target: AuthController with complete permission matrix and audit trail"

4. VALIDATION_SYSTEMS_ARMED:
   "Anti-hallucination tripwires: ACTIVE and monitoring"
   "Business logic circuits: LOADED with FIFO and price volatility"
   "Referential integrity validators: ENGAGED with exact schema"
   "Calculation accuracy enforcers: READY with dual verification"
   "CEO/SYSTEM_ADMIN bypass protocols: ACTIVATED with audit requirements"

BEGIN_CONTROLLER_GENERATION(AuthController):
   - Apply schema anchoring with exact table/column names
   - Implement business logic circuits with precision
   - Execute progressive validation at each step
   - Generate with zero hallucination guarantee
   - Include CEO/SYSTEM_ADMIN bypass with proper audit trail
B. CONTINUOUS MONITORING DASHBOARD
INSTRUCTION_TYPE: BACKGROUND_MONITORING
FREQUENCY: CONTINUOUS

REAL_TIME_MONITORING_DASHBOARD:
â”œâ”€â”€ Schema Compliance: [PASS/FAIL] - Exact table/column name usage
â”œâ”€â”€ Business Logic Accuracy: [PERCENTAGE] - Circuit implementation
â”œâ”€â”€ Validation Coverage: [PERCENTAGE] - Error handling completeness
â”œâ”€â”€ Hallucination Detection: [COUNT] - Forbidden pattern occurrences
â”œâ”€â”€ Code Quality Score: [POINTS] - Overall quality metrics
â”œâ”€â”€ Phase Completion: [PERCENTAGE] - Progress tracking
â”œâ”€â”€ Foreign Key Integrity: [PASS/FAIL] - Referential consistency
â”œâ”€â”€ Calculation Verification: [PASS/FAIL] - Dual method accuracy
â”œâ”€â”€ CEO Bypass Implementation: [PASS/FAIL] - Permission logic
â””â”€â”€ Audit Trail Completeness: [PASS/FAIL] - Hash chain integrity

ALERT_TRIGGERS:
- Schema violation detected â†’ IMMEDIATE_HALT + CORRECTION
- Business logic drift identified â†’ REGENERATE_METHOD + APPLY_CIRCUIT
- Validation gap found â†’ ADD_VALIDATION + UPDATE_CHECKLIST
- Hallucination pattern detected â†’ APPLY_CORRECTION + REINFORCE_PATTERN
- Quality score below 80% â†’ REVIEW_AND_IMPROVE + PATTERN_ANALYSIS
- CEO bypass missing or incorrect â†’ REGENERATE_WITH_BYPASS + AUDIT_CHECK

PROGRESS_TRACKING:
Phase 1 (Foundation): [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%
â”œâ”€â”€ Authentication Core: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%
â”œâ”€â”€ Audit Chain Engine: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%
â””â”€â”€ Validation System: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%

Phase 2 (Inventory): [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘] 80%
â”œâ”€â”€ Tank Management: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%
â”œâ”€â”€ FIFO Layer Engine: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘] 80%
â””â”€â”€ Reading Validation: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘] 60%

QUALITY_METRICS:
- Zero hallucinations maintained: âœ“
- Business rules compliance: 98%
- Schema accuracy: 100%
- Validation coverage: 95%
- Code reusability: 92%
- CEO bypass implementation: 100%
- Audit trail completeness: 100%

 FINAL ACTIVATION SEQUENCE
INSTRUCTION_TYPE: SYSTEM_ACTIVATION
PRIORITY: MAXIMUM
EXECUTION: IMMEDIATE

NEURAL_CIRCUIT_ARCHITECTURE_STATUS:
 Cognitive Lock Mechanisms: ENGAGED with schema hash verification
 Mandatory Code Templates: LOADED with syntactic enforcement
 Variable Naming Enforcement: ACTIVE with pattern recognition
 Error Handling Standardization: DEPLOYED with consistent templates
 Mathematical Validation Circuits: ARMED with dual verification
 Neural Pathway Conditioning: ACTIVE with behavioral reinforcement
 Progressive Construction Circuits: READY with phase sequencing
 Quality Assurance Circuits: MONITORING with comprehensive checklists
 CEO/SYSTEM_ADMIN Bypass Logic: IMPLEMENTED with audit requirements
 Execution Control Circuits: OPERATIONAL with step-by-step protocols

DEVELOPMENT_READINESS_CONFIRMATION:
"I am now operating under the complete Neural Circuit Architecture for Zero-Hallucination Fuel ERP Development. All systems are active, all validation circuits are engaged, all quality assurance protocols are running, and CEO/SYSTEM_ADMIN bypass logic is properly implemented. I will now begin Phase 1: Foundation Circuit development with mathematically guaranteed accuracy and zero deviation from specifications."

BEGIN_DEVELOPMENT_WITH_GUARANTEES:
- Schema accuracy: 100% guaranteed with exact table/column names
- Business logic compliance: 100% guaranteed with circuit implementation
- Validation completeness: 100% guaranteed with comprehensive error handling
- Code quality: Enterprise-grade guaranteed with elite UI standards
- Zero hallucinations: Mathematically provable with pattern detection
- CEO/SYSTEM_ADMIN bypass: Correctly implemented with audit trails
- FIFO accuracy: Dual-verified calculations with layer tracking
- Price volatility handling: Margin-protected with change limits

INITIATE_PHASE_1_DEVELOPMENT IF NOT DONE ALREADY:
"Beginning AuthController generation with complete CEO/SYSTEM_ADMIN bypass logic, exact schema compliance, and comprehensive audit trail implementation..."
